<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>
		CollaboRate v1.3 - Micro-Work Binary Breakdown Structure (MWBBS) Tool for Crowdsourced IT
	</title>
	<!-- 
	Project website: https://github.com/sohrabsaran/CollaboRate	
	Copyright Sohrab Saran (sohrabsaran@gmail.com) and additional contributors listed at https://github.com/sohrabsaran/CollaboRate/wiki/Contributors
	License type: MIT	
	-->
	<style>
		* {font-family: Sans-Serif;}
		pre 
		{
			display:inline;
			white-space: pre-wrap;       /* css-3 */
			white-space: -moz-pre-wrap;  /* Mozilla, since 1999 */
			white-space: -pre-wrap;      /* Opera 4-6 */
			white-space: -o-pre-wrap;    /* Opera 7 */
			word-wrap: break-word;       /* Internet Explorer 5.5+ */
		}

		div
		{
			display:none;/*hide divs by default*/
			padding-left: 5px;/*so that nested divs can be visualized*/
		}		
	</style>
	<!--
	<script
		src="https://code.jquery.com/jquery-3.1.1.slim.min.js"
		integrity="sha256-/SIrNqv8h6QGKDuNoLGA4iret+kyesCkHGzVUUV0shc="
		crossorigin="anonymous">
	</script>
	--->
	<script src="jquery-3.1.1.slim.min.js"></script>	
	<script>
//BEGIN src="https://raw.githubusercontent.com/spencertipping/jquery.fix.clone/master/jquery.fix.clone.js">
		// Textarea and select clone() bug workaround | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Motivation.
// jQuery's clone() method works in most cases, but it fails to copy the value of textareas and select elements. This patch replaces jQuery's clone() method with a wrapper that fills in the
// values after the fact.

// An interesting error case submitted by Piotr Przybyl: If two <select> options had the same value, the clone() method would select the wrong one in the cloned box. The fix, suggested by Piotr
// and implemented here, is to use the selectedIndex property on the <select> box itself rather than relying on jQuery's value-based val().

(function (original) {
  jQuery.fn.clone = function () {
    var result           = original.apply(this, arguments),
        my_textareas     = this.find('textarea').add(this.filter('textarea')),
        result_textareas = result.find('textarea').add(result.filter('textarea')),
        my_selects       = this.find('select').add(this.filter('select')),
        result_selects   = result.find('select').add(result.filter('select'));

    for (var i = 0, l = my_textareas.length; i < l; ++i) $(result_textareas[i]).val($(my_textareas[i]).val());
    for (var i = 0, l = my_selects.length;   i < l; ++i) {
      for (var j = 0, m = my_selects[i].options.length; j < m; ++j) {
        if (my_selects[i].options[j].selected === true) {
          result_selects[i].options[j].selected = true;
        }
      }
    }
    return result;
  };
}) (jQuery.fn.clone);

// Generated by SDoc 
//END src="https://raw.githubusercontent.com/spencertipping/jquery.fix.clone/master/jquery.fix.clone.js">

//shortcut for document.getElementById or for ($("#"+eleid)[0]))
function el(eleid){return document.getElementById(eleid)}

//Shows the div for the currently selected option
function showDivForCurrentlySelectedOption(drpdn, optionDivsClass)
{
	var dbg = false;
	if(dbg)
	{
		console.log("showDivForCurrentlySelectedOption(): drpdn="+drpdn.outerHTML);
		console.log("showDivForCurrentlySelectedOption(): drpdn="+drpdn.outerHTML);
		console.log("showDivForCurrentlySelectedOption(): optionDivsClass='"+optionDivsClass+"'");
		console.log("showDivForCurrentlySelectedOption(): drpdn.value (id of div to make visible) = '"+drpdn.value+"'");
	}
	$("."+optionDivsClass).hide();
	if(drpdn.value != ""){$("#"+drpdn.value).show();}
	if(dbg)
	{
		console.log("showDivForCurrentlySelectedOption(): now check whether the element with id '"+drpdn.value+"' has been made visible.");
		console.log("showDivForCurrentlySelectedOption(): number of elements with id '"+drpdn.value+"' are "+$("#"+drpdn.value).length);
	}
}

function optionChanged_howBigSpecific(drpdn, optionDivsClass)
{
	showDivForCurrentlySelectedOption(drpdn, optionDivsClass);
	if(drpdn.value != ""){$("#btnToshowNextSteps").show();}
}

var eleIdsDifferentiator = 0;
var replacements;

String.prototype.replaceAll = function(search, replacement) {
    var target = this;
    return target.replace(new RegExp(search, 'g'), replacement);
};

var dbgWithIdsMadeDifferent = false;

//returns a string of the outerHTML of the specified eleId but all all ids and reference to those ids made different.
function withIdsMadeDifferent(eleId)
{
	if(dbgWithIdsMadeDifferent)
	{
		console.log("withIdsMadeDifferent(): On entry, eleId='"+eleId+"', ($(\"#\"+eleId)[0]).outerHTML='"+($("#"+eleId)[0]).outerHTML+"'...");
	}
	var s = withIdsMadeDifferentButNotReferencesToThem(($("#"+eleId).clone(true,true))[0]).outerHTML;
	if(dbgWithIdsMadeDifferent)
	{
		console.log("withIdsMadeDifferent(): After withIdsMadeDifferentButNotReferencesToThem(), eleId='"+eleId+"', s='"+s+"'...");
	}
	for (var key in replacements)
	{
		if(dbgWithIdsMadeDifferent)
		{
			console.log("withIdsMadeDifferent(): string to replace = '"+key+"', replacement = '"+replacements[key]+"'");
		}
		s = s.replaceAll(key,replacements[key]);
		if(dbgWithIdsMadeDifferent)
		{
			console.log("withIdsMadeDifferent(): Now s='"+s+"'...");
		}
	}
	if(dbgWithIdsMadeDifferent)
	{
		console.log("withIdsMadeDifferent(): On exit, s='"+s+"'...");
	}
	return s;
}

function withIdsMadeDifferentButNotReferencesToThem(ele)
{	
	withIdsMadeDifferentButNotReferencesToThemInit()
	withIdsMadeDifferentButNotReferencesToThemLoop(ele);
	return ele;
}

function withIdsMadeDifferentButNotReferencesToThemInit()
{
	eleIdsDifferentiator++
	replacements = {}
}

function withIdsMadeDifferentButNotReferencesToThemLoop(ele)
{
	if(ele.id != null && ele.id != "")
	{
		var oldEleId = ele.id;
		
		//this will prevent double-replacement of the oldEleId:
		ele.id = ele.id.substring(0,1) +eleIdsDifferentiator + ele.id.substring(1);
		
		replacements[oldEleId] = ele.id;
	}	
	var cn = ele.childNodes;
	for(var i=0;i<cn.length;i++)
	{
		withIdsMadeDifferentButNotReferencesToThemLoop(cn[i]);
	}	
}

function copyFromTaskSummary(destinationTextbox)
{	
	destinationTextbox.value = ($("#taskSummary")[0]).value + destinationTextbox.value;
}

function copyFromTaskDesc(destinationTextbox)
{		
	//console.log("destinationTextbox.outerHTML="+destinationTextbox.outerHTML)
	destinationTextbox.value = ($("#taskDesc")[0]).value + destinationTextbox.value;
}

function getTextOfNode(n)
{
	//console.log("gettextofnode: entry");
	if(!($(n).is(':visible'))){return ""}
	if(n.tagName=="BUTTON"){return ""}
	if(n.tagName=="SELECT")
	{
		//console.log(n.outerHTML)
		var r = n.options[n.selectedIndex].text
		//console.log("For select, returning '"+r+"'...")
		return r
	}
	if(n.childNodes.length==0)
	{
		if(n.text!=undefined){return n.text;}
		if(n.value!=undefined){return n.value;}
	}
	var t = "";
	//console.log("Getting ")
	$(n.childNodes).each(function()
	{
		//console.log("this="+this.outerHTML);
		t+= getTextOfNode(this);
	});
	//console.log("n.outerText='"+n.outerText+"', n='"+n.outerHTML+"', n.innerText='"+n.innerText+"'");
	return t;
}

var dbg_getTextToReplyWith_uniquectr 

function getTextToReplyWith()
{
	var ele = $('#divThatCreatesTheTextToReplyWith')[0];
	dbg_getTextToReplyWith_uniquectr = 0
	return getTextToReplyWithFrom(ele,0)
}

function getTextToReplyWithFrom(ele,indentationLevel)
{
	var dbg = false	
	if(dbg)
	{
		dbg_getTextToReplyWith_uniquectr++
		var dbgmyid = dbg_getTextToReplyWith_uniquectr
	}
	//console.log("ele.outerHTML = "+ele.outerHTML)
	//console.log("ele.innerText = "+ele.innerText)
	//console.log("ele.textContent = "+ele.textContent)
	//return ele.innerText
	//if(!($(ele).is(':visible'))){return ""}
	if(ele.tagName=="DIV" && getComputedStyle(ele).getPropertyValue("display") == "none"){return ""}
	if(ele.tagName=="SCRIPT"){return ""}
	if(ele.tagName=="BUTTON"){return ""}
	if(ele.tagName=="BR"){return "\n"}
	if((ele.tagName == "INPUT" && ele.type == "text") || (ele.tagName == "TEXTAREA"))
	{
		return ele.value
	}
	if(ele.tagName=="SELECT")
	{
		return ele.options[ele.selectedIndex].text
	}
	var s = ""	
	if(ele.nodeType == 3)
	{		
		var r = ele.nodeValue.trim()//trims whitespaces and not just spaces!
		if(r != ele.nodeValue){return r + " "}
		return r
	}
	var indent, ctr, dbgmyid;
	if(dbg)
	{
		ctr=0
		indent = "    ".repeat(indentationLevel)
		s+=indent+"START dbgmyid="+dbgmyid+", tagName="+ele.tagName+",nodeType="+ele.nodeType+"\n"
	}
	$(ele).contents().each(function(){
		if(dbg)
		{			
			s+=indent+"dbgmyid="+dbgmyid+", ele at idx "+ctr+":\n"
			s+=getTextToReplyWithFrom(this,indentationLevel+1)
			s+="\n"+indent+"dbgmyid="+dbgmyid+", end ele at idx "+ctr+"\n";
			ctr++
		}
		else
		{
			s+=getTextToReplyWithFrom(this,indentationLevel+1);
		}
	});
	if(dbg)
	{
		s+=indent+"END dbgmyid="+dbgmyid+", tagName="+ele.tagName+",nodeType="+ele.nodeType+"\n"
	}
	return s;
}



function showNextSteps()
{
	($("#textToReplyWith")[0]).value = getTextToReplyWith()
	$("#divForNextSteps").show();	
	window.scrollTo(0,$('#nextStepsCaption').offset().top);	
}

function isValidEleId(id)
{
	return (document.getElementById(id ) != null)
}

function assert(b)
{
	if(!b){throw new Error("Assertion failed");}
}

var gldbg = false;

function appendVisibleElementClone(parentEleId,childEleId)
{
	assert(isValidEleId(parentEleId))
	assert(isValidEleId(childEleId))
	var wasVisible = $("#"+childEleId).is(":visible");
	if(!wasVisible)
	{
		$("#"+childEleId).show();
	}
	var cch = withIdsMadeDifferent(childEleId)
	if(gldbg){console.log(cch)}
	$("#"+parentEleId).append(cch);	
	if(!wasVisible)
	{
		$("#"+childEleId).hide();
	}
}

function setupDisplayOfNumOfCharsTypedAndCharLimit(container)
{
	//console.log("In setupDisplayOfNumOfCharsTypedAndCharLimit(container)...")
    var eles = null;
    //assert(document.forms.length==1);
    //eles = $(document.forms[0].elements);
	eles = $(":input");
	//console.log("eles.length=" + eles.length)
    /**/if(container != null)
    {
        eles = eles.filter(function(index,ele)
        {
            return $.contains(container,ele);
        });
    }/**/
	//console.log("Now eles.length=" + eles.length)
    eles.each(function()
    {
		//console.log("hmmm")
        var ele = this;
        if(ele.maxLength == null || ele.maxLength <= 0 || ele.maxLength == 2147483647){return;}
		//console.log("Applying remaining char count display to '"+ele.outerHTML+"'...")
        ele.style.display ="inline";
        $(ele).focusin(showNumOfCharsTypedAndCharLimit);
        $(ele).focusout(hideNumOfCharsTypedAndCharLimit);
    });
}

function showNumOfCharsTypedAndCharLimit()
{
    //console.log("showNumOfCharsTypedAndCharLimit(): Entry....");
    var textEle = this;
    var textEleIdOrName = textEle.id//getEleIdOrName(textEle);
    var spanId = "SpanIdForNumOfCharsTypedAndCharLimitFor"+textEleIdOrName;
    $(textEle).after("<span id=\""+spanId+"\" style=\"display:inline !important;white-space:nowrap;font-size:smaller;\"></span>");
    $(textEle).keyup(function(){
        //console.log("showNumOfCharsTypedAndCharLimit(): keyup handler....");
        $("#"+spanId)[0].innerText = textEle.value.length + "/"+textEle.maxLength+" chars";
        //console.log("Updated the innerText variable for span with id '"+spanId+"' to '"+$("#"+spanId)[0].innerText+"'");
    });
    $(textEle).keyup();
}

function hideNumOfCharsTypedAndCharLimit()
{
    var textEle = this;
    //console.log("hideNumOfCharsTypedAndCharLimit(): Entry....");
    var textEleIdOrName = textEle.id//getEleIdOrName(textEle);
    var spanId = "SpanIdForNumOfCharsTypedAndCharLimitFor"+textEleIdOrName;
    $("#"+spanId).remove();
}

</script>
</head>
<body>
<H2 id="pageheading">
	<script>
		$(function(){$("#pageheading").append(document.title);});
	</script>
</H2>
<div style="text-align:center;display:block !important;"><small>Mostly tested with Mozilla FireFox</small></div>
<a href=# onclick="window.open('https://github.com/sohrabsaran/CollaboRate#collaborate---a-crowdsourcing-process-and-software-tool');return false");">Help</a><br>
<br>
This tool will guide you to break down the task sent to you via email.<br>
<br>
<b>Task Summary</b> <button onclick="alert(el('taskSummary').placeholder)">?</button><br><!--(the phrase 'create function' in summary could be taken as a keyword for some workflow/validations)--> 
</pre><input id="taskSummary" size="120" type="text" 
placeholder="Copy the task summary from the email and paste it here."><!--style="background:#eeeeee"--><pre> 

</PRE><b>Task Description</b> <button onclick="alert(el('taskDesc').placeholder)">?</button> <br>
<textarea rows="5" cols="120" id="taskDesc" placeholder="Copy the task description from the email and paste it here.">
</textarea><!--style="background:#eeeeee;"--><br>
Note: Before you break down this task, check that its description is clear and complete. It must not refer to any other task or diagram.<br> 
Otherwise, bring this to the notice of the task creator and ensure that you receive a clear and complete task description.<br>
<br>
<b style="color:red">Note that you do not need to fully solve this task!</b> <button type="button" 
onclick="alert(($('#divForExplanationForWhyYouDoNotNeedToFullySolveThisTask')[0]).innerText)">?</button>
<br>
<div id="divForExplanationForWhyYouDoNotNeedToFullySolveThisTask">
As per the CollaboRate process, you do not need to fully solve an assigned task.<br>
Your microtask is just to break down this task into 2 parts.<br> 
Both parts usually yield subtasks. <br>
Sometimes the task assigned is so small that it may yield 1 subtask or even no subtask.<br>
Other crowd members will break down the subtasks you create.<br> 
Additionally, once your breakdown is reviewed, you must act as the reviewer for the break down of these subtasks.<br>
<br>
To do more work, you break down other tasks.
</div>
<br>

<!--Though it is hoped that this tool will be used by non-programmers as well, basic understanding of programming concepts is useful.<br>-->

<div id="divThatCreatesTheTextToReplyWith" style="display:block;background:#eeeeff;">
<b>Does this task specify the creation of a function (a sequence of steps)?</b> <select 
	id="isThisAFnDropdown" onchange="showDivForCurrentlySelectedOption(this, 'classfordivfordoesthistaskspecifyfnoption');">
<option>&nbsp;</option>
<option value="divfortaskthatspecifiescreationofafunction">Yes</option>
<option value="divfortaskthatdoesnotspecifycreationofafunction">No</option>
</select><br><br>

<div id="divfortaskthatspecifiescreationofafunction" class="classfordivfordoesthistaskspecifyfnoption" 
style="background:#ffe066">
(Question applicable for projects where task visibility is unrestricted e.g. experimental or open-source projects. Answer 'yes' if not applicable):<br>
<b> Has go-ahead to crowdsource this task been given by BOTH programming language/third-party code-reuse SPOC, and also by the code reuse SPOC?</b> 
(contact the SPOCs if you are not sure how go-aheads are mentioned) <select 
onchange = "showDivForCurrentlySelectedOption(this,'classfordivforhasfngoaheadbeengiven')"
<!--onchange2="if(this.value=='no'){console.log('You need to get approval before breaking down this task.');}else{;$('#divtoshowforcreationofapprovedfn').show();}"-->
>
<option>&nbsp;</option>
<option value="divtoshowforcreationofapprovedfn">Yes</option>
<option value="needtogetapprovalmsgdiv">No</option>
</select><br><br>

<div id="needtogetapprovalmsgdiv" class="classfordivforhasfngoaheadbeengiven" style="background:#ff4d4d">
You need to get approval before breaking down this task.
</div>

<div id="divtoshowforcreationofapprovedfn" class="classfordivforhasfngoaheadbeengiven" style="background:#eeeeff" >
<b>What is the best way to break down this function?</b>  
<select id="taskSplitTypeDropdown" onchange="optionChanged_howBigSpecific(this,'bigtaskoption');">
	<option>&nbsp;</option>	
	<option value="nonObviousReqAndElaboratedNewFn">Break it down into a non-obvious requirement, and a new task for this function, but with more details.</option>
	<option value="needsSubFns">Call other functions.</option>
	<option value="unnecessaryJustNeedsToReturnConstant">This task is unnecessary. This function just needs to return a constant!</option>
</select><br><br>

<div class="bigtaskoption" id="unnecessaryJustNeedsToReturnConstant">
<script>
$(function(){appendVisibleElementClone("unnecessaryJustNeedsToReturnConstant", "returnConstant")})
</script>
</div>

<div class="bigtaskoption" id="nonObviousReqAndElaboratedNewFn">
<div style="display:block !important;background:#ffeeee;" id="nonObviousReqOrUseCase">
<b>Enter the details for the non-obvious requirement</b><br><br>
<script>
$(function(){appendVisibleElementClone("nonObviousReqOrUseCase", "summAndDesc")})
</script>
</div><!-- nonObviousReqOrUseCase -->
<pre> 

Enter the more detailed technical description for this new function to be created
</pre>
<script>
$(function(){appendVisibleElementClone("nonObviousReqAndElaboratedNewFn","newfndetails")})
</script>
</div><!-- end div nonObviousReqAndElaboratedNewFn-->

<div class="bigtaskoption" id="needsSubFns" style="background:#b3ffff">
Basic code block that joins the 1-2 new functions:
<select id="codeblockdropdown" onchange="showDivForCurrentlySelectedOption(this, 'classforcodeblockdiv')">
<option>&nbsp;</option>
<option value="divtoshowforfncallsequence">sequence - function1();return something; - Call function1. Then return something.</option>
<option value="divtoshowforifsequence">if(function1()){return something}else{return false} - If function1 returns 'true' then return something, else return 'false'</option>
<option value="divtoshowforloopsequence">while(function1()){function2()} - While function1 returns 'true', keep calling function2</option>
<option value="divforcallingreadymadefn">return readymadefunction(something1,something2)</value>
</select><br><br>

<div id="divforcallingreadymadefn" class="classforcodeblockdiv">
Select the readymade function to call <select 
id="readymadedropdown" onchange="showDivForCurrentlySelectedOption(this, 'classforreadymadefncalldiv')">
<option>&nbsp;</option>

<option value="divtogetuserinputfromscreen">Get user input from the screen as a string</option>
<!-- 
params:
1. Something that returns the unique name of the screen of the input field
2. Something that returns the unique name of the input field on the screen
-->

<option value="divtogetattrofobjorelofarr">Get attribute of object or element of array</option>
<!-- 
params:
1. something that returns object/array name
2. something that returns attribute name/value of 0-based index
-->

<option value="divtogetsomethingpreviouslymemorized">Get something that was quickly memorized</option>
<!-- params: 
	1. something that returns the variable name.
-->

<option value="divtogetsomethingpreviouslymemorizedforsession">Get something that was memorized for the web browser session</option>
<!-- params: 
	1. something that returns the variable name.
-->

<option value="divtoshowforreadfromdb">Read object(s) from database</option>
<!-- params: 
1. something that returns the table name, (always fetches columns of this table and not of joined table, we will have unique names and mysql enums rather than id,pk,fk etc.)
2. sql select 'where' clause function (filter function) whose return type is boolean - if false then object to check gets filtered out. 
The object to check is already stored in memory with name 'objectToFilter'
So parameters are limited to <=2 for binary WBS
-->

<option value="divtoquicklymemorizesomething">Quickly memorize something for later reference in this simple use case</option>
<!-- store value in a per-thread global variable.  
params (limited to <=2 for binary WBS): 
1  name: something that returns the name by which to memorize the data
2. value: something that returns the object or value to be memorized
-->

<option value="divtomemorizesomethingforthesession">Memorize something for the browser session</option>
<!-- store value in a session variable.  
params (limited to <=2 for binary WBS): 
1  name: something that returns the name by which to memorize the data
2. value: something that returns the object or value to be memorized
-->

<option value="divtoinsnewobjindb">Insert new object in the database and return the unique id generated</option>
<!-- 
params:
1. something that returns the object to insert 
2. something that returns the name of the table in which to insert the object
Returns: id of inserted row 
-->

<option value="divforupdatedb">Update existing objects in the database</option>
<!-- 
params:
1. function to read objects from the database
2. function to modify an object. The object is passed to the function via a memory variable named 'objectToUpdate'
-->

<option value="divtoupdatepropofpartofscreen">Update property of a part of the screen</option>
<!--
params:
1. something to give the name of the part of the screen to update (in format <screen name>_<field name>_<property name>
2. something to give the new value to assign to the property
-->

<option value="divformiscreadymadefn">Any other miscellaneous readymade function that should exist, having not more than 2 inputs</option>
<!--
params:
1. Something1
2. Something2
-->

</select><br><br>

<div id="divtogetuserinputfromscreen" class="classforreadymadefncalldiv">
<!-- 
Get user input from the screen as a string
params:
1. Something that returns the unique name of the screen of the input field.
2. Something that returns the unique name of the input field on the screen.
-->
<div style="display:block;background:#cce6ff" id="divforscreenname">
<b>Unique name of the screen of the input field</b><br>
<script>$(function(){appendVisibleElementClone("divforscreenname", "returnconstantornewfn")})</script>
</div>
<div style="display:block;background:#b3d9ff" id="divforfieldnameonitsscreen">
<b>Unique name of the input field on its screen</b><br>
<script>$(function(){appendVisibleElementClone("divforfieldnameonitsscreen", "returnconstantornewfn")})</script>
</div>
</div>

<div id="divtogetattrofobjorelofarr" class="classforreadymadefncalldiv">
<!-- 
Get attribute of object or element of array
params:
1. something that returns object/array
2. something that returns attribute name/value of 0-based index
-->
<div style="display:block;background:#cce6ff" id="divforobjorarr">
<b>Object or array</b><br>
<script>$(function(){appendVisibleElementClone("divforobjorarr", "newfndetails")})</script>
</div>
<div style="display:block;background:#b3d9ff" id="divforattrname">
<b>Attribute name of object, or value of the 0-based index</b><br>
<script>$(function(){appendVisibleElementClone("divforattrname", "returnconstantornewfn")})</script>
</div>
</div>

<div id="divtogetsomethingpreviouslymemorized"  class="classforreadymadefncalldiv">
<!-- params: 
	1. something that returns the variable name.
-->
<b>Memory Variable name</b><br>
<script>$(function(){appendVisibleElementClone("divtogetsomethingpreviouslymemorized", "returnconstantornewfn")})</script>
</div>

<div id="divtogetsomethingpreviouslymemorizedforsession" class="classforreadymadefncalldiv">
<!-- params: 
	1. something that returns the variable name.
-->
<b>Session Variable name</b><br>
<script>$(function(){appendVisibleElementClone("divtogetsomethingpreviouslymemorizedforsession", "returnconstantornewfn")})</script>
</div>

<div id="divtoshowforreadfromdb" class="classforreadymadefncalldiv">
<!-- 
Read object(s) from database
params: 
1. something that returns the table name, (always fetches columns of this table and not of joined table, we will have unique names and mysql enums rather than id,pk,fk etc.)
2. sql select 'where' clause function (filter function) whose return type is boolean - if false then object to check gets filtered out. 
The object to check is already stored in memory with name 'objectToFilter'
So parameters are limited to <=2 for binary WBS
-->
<div style="display:block;background:#cce6ff" id="divfortablename">
<b>Table Name</b><br>
<script>$(function(){appendVisibleElementClone("divfortablename", "returnconstantornewfn")})</script>
</div>
<div style="display:block;background:#b3d9ff" id="divforfilterfn">
<b>Filter function whose return type is 'true' or 'false' - if false, then the object to check gets filtered out.</b><br>
Note: The object to check will already stored in memory by the readymade function, with name 'objectToFilter'<br>
<script>$(function(){appendVisibleElementClone("divforfilterfn", "newfndetails")})</script>
</div>
</div>

<div id="divtoquicklymemorizesomething" class="classforreadymadefncalldiv">
<!-- store value in a per-thread global variable.  
params (limited to <=2 for binary WBS): 
1  name: something that returns the name by which to memorize the data
2. value: something that returns the object or value to be memorized
-->
<div style="display:block;background:#cce6ff" id="divformemvarnametowriteto">
<b>Unique name of the memory location (variable)</b><br>
<script>$(function(){appendVisibleElementClone("divformemvarnametowriteto", "returnconstantornewfn")})</script>
</div>
<div style="display:block;background:#b3d9ff" id="divfordatatomemorizeinmemvar">
<b>Data to memorize</b><br>
<script>$(function(){appendVisibleElementClone("divfordatatomemorizeinmemvar", "returnconstantornewfn")})</script>
</div>
</div>

<div id="divtomemorizesomethingforthesession" class="classforreadymadefncalldiv">
<!-- store value in a per-thread global variable.  
params (limited to <=2 for binary WBS): 
1  name: something that returns the name by which to memorize the data
2. value: something that returns the object or value to be memorized
-->
<div style="display:block;background:#cce6ff" id="divformemsessionvarnametowriteto">
<b>Unique name of the session memory location (variable)</b><br>
<script>$(function(){appendVisibleElementClone("divformemsessionvarnametowriteto", "returnconstantornewfn")})</script>
</div>
<div style="display:block;background:#b3d9ff" id="divfordatatomemorizeinsessionmemvar">
<b>Data to memorize</b><br>
<script>$(function(){appendVisibleElementClone("divfordatatomemorizeinsessionmemvar", "returnconstantornewfn")})</script>
</div>
</div>

<div id="divtoinsnewobjindb" class="classforreadymadefncalldiv">
<!-- 
Insert new object in the database and return the unique id generated
params:
1. something that returns the object to insert 
2. something that returns the name of the table in which to insert the object
Returns: id of inserted row 
-->
<div style="display:block;background:#cce6ff" id="divforobjtoins">
<b>Object to insert</b><br>
<script>$(function(){appendVisibleElementClone("divforobjtoins", "returnconstantornewfn")})</script>
</div>
<div style="display:block;background:#b3d9ff" id="divfornameoftabletoinsinto">
<b>Name of table to insert the object into</b><br>
<script>$(function(){appendVisibleElementClone("divfornameoftabletoinsinto", "returnconstantornewfn")})</script>
</div>
</div>

<div id="divforupdatedb" class="classforreadymadefncalldiv">
<!-- 
Update existing objects in the database
params:
1. function to read objects from the database
2. function to modify an object. The object is passed to the function via a memory variable named 'objectToUpdate'
-->
<div style="display:block;background:#cce6ff" id="divforfntoreadobjstoupdate">
<b>Function to read objects from the database</b><br>
<script>$(function(){appendVisibleElementClone("divforfntoreadobjstoupdate", "newfndetails")})</script>
</div>
<div style="display:block;background:#b3d9ff" id="divforfntoupdatedbobj">
<b>function to modify an object. The object is passed to the function via a memory variable named 'objectToUpdate'</b><br>
<script>$(function(){appendVisibleElementClone("divforfntoupdatedbobj", "newfndetails")})</script>
</div>
</div>

<div id="divtoupdatepropofpartofscreen" class="classforreadymadefncalldiv">
<!--
Update property of a part of the screen
params:
1. something to give the name of the part of the screen to update (in format <screen name>_<field name>_<property name>)
2. something to give the new value to assign to the property
-->
<div style="display:block;background:#cce6ff" id="divfornameofpartofscreentoupdate">
<b>Name of the part of the screen to update (in format &lt;screen name&gt;_&lt;field name&gt;_&lt;property name&gt;)</b><br>
<script>$(function(){appendVisibleElementClone("divfornameofpartofscreentoupdate", "returnconstantornewfn")})</script>
</div>
<div style="display:block;background:#b3d9ff" id="divforvaluetogivetoscreenpart">
<b>Value to assign to the property of the screen part</b><br>
<script>$(function(){appendVisibleElementClone("divforvaluetogivetoscreenpart", "returnconstantornewfn")})</script>
</div>
</div>

<div id="divformiscreadymadefn">
<!--
Any other miscellaneous readymade function that should exist, having not more than 2 inputs
params:
1. Something1
2. Something2
-->
<div style="display:block;background:#ffb3d9" id="divforfnnameanddescofmiscreadymadefn">
<script>$(function(){appendVisibleElementClone("divforfnnameanddescofmiscreadymadefn", "newfndetails")})</script>
</div>
<div style="display:block;background:#cce6ff" id="divforfirstparamofmiscreadymadefn">
<b>First Parameter</b><br>
<script>$(function(){appendVisibleElementClone("divforfirstparamofmiscreadymadefn", "returnconstantornewfn")})</script>
</div>
<div style="display:block;background:#b3d9ff" id="divforsecondparamofmiscreadymadefn">
<b>Second Parameter (if applicable)</b><br>
<script>$(function(){appendVisibleElementClone("divforsecondparamofmiscreadymadefn", "returnconstantornewfn")})</script>
</div>
</div>

</div><!-- end div divforcallingreadymadefn -->


<div id="divtoshowforloopsequence" class="classforcodeblockdiv">
	<div id="divforloopconditionfn" style="display:block;background:#ffff80;">
		<b>Loop Condition Function</b><br>
		<script>
		$(function()
		{
			appendVisibleElementClone("divforloopconditionfn", "newfndetails");
			var idofclonedele = replacements["fnreturntype"];
			//console.log("idofclonedele="+idofclonedele);
			var fnReturnTypeTextbox = $("#"+idofclonedele)[0];
			fnReturnTypeTextbox.value = "boolean (returns 'true' or 'false')";
			fnReturnTypeTextbox.readOnly = true;
			fnReturnTypeTextbox.style.backgroundColor = "#eeeeee";
		});
		</script>
	</div>
	<div id="divforfntocallrepeatedly" style="display:block;background:#ffff00">
		<b>Function to call in the loop</b><br>
		<script>
		$(function(){appendVisibleElementClone("divforfntocallrepeatedly", "newfndetails")})
		</script>
	</div>
</div>


<div id="divtoshowforifsequence" class="classforcodeblockdiv" >
	<div id="divforconditionfn" style="display:block;background:#f2e6ff">
		<b>Condition Function</b><br>
		<script>
		$(function()
		{
			appendVisibleElementClone("divforconditionfn", "newfndetails");
			var idofclonedele = replacements["fnreturntype"];
			//console.log("idofclonedele="+idofclonedele);
			var fnReturnTypeTextbox = $("#"+idofclonedele)[0];
			fnReturnTypeTextbox.value = "boolean (returns 'true' or 'false')";
			fnReturnTypeTextbox.readOnly = true;
			fnReturnTypeTextbox.style.backgroundColor = "#eeeeee";
		});
		</script>
	</div>
	<div id="divforvaluetoreturnifcondfnreturnstrue" style="display:block;background:#e6ccff">
		<b>Value to return, in case the condition function returns 'true'</b><br>
		<script>
		$(function(){appendVisibleElementClone("divforvaluetoreturnifcondfnreturnstrue", "returnconstantornewfn")})
		</script>		
	</div>
</div>



<div id="divtoshowforfncallsequence" class="classforcodeblockdiv">
	<div id="divforfirstfncallinthesequence" style="display:block;background:#99ccff">
		<b>First function called in the sequence</b><br>
		<script>
		$(function()
		{
			appendVisibleElementClone("divforfirstfncallinthesequence", "newfndetails");
			var idofclonedele = replacements["fnreturntype"];
			//console.log("idofclonedele="+idofclonedele);
			var fnReturnTypeTextbox = $("#"+idofclonedele)[0];
			fnReturnTypeTextbox.value = "(void or ignored)";
			fnReturnTypeTextbox.readOnly = true;
			fnReturnTypeTextbox.style.backgroundColor = "#eeeeee";
		});
		</script>
	</div>
	<div id="divforvaluetoreturn" style="display:block;background:#bbbbff;">
		<b>Overall result of the sequence</b><br>
		<script>
		$(function(){appendVisibleElementClone("divforvaluetoreturn", "returnconstantornewfn")})
		</script>
	</div>
</div>

<div id="divtoshowforreadfromdb" class="classforcodeblockdiv">
<b>Read from db</b><br>
Function that provides Table name (TODO)<br>
Function that provides Column name (TODO)<br>
Function that provides row id (TODO)<br>
</div>

</div><!--end of div needsSubFns -->

</div><!-- divtoshowforcreationofapprovedfn -->

</div><!-- divfortaskthatspecifiescreationofafunction -->


<div id="divfortaskthatdoesnotspecifycreationofafunction" class="classfordivfordoesthistaskspecifyfnoption" 
style="background:#f0ddff">
Is this task a requirement, or is it a 'simple use case'? <button type="button" 
onclick="alert($('#divForWhatIsASimpleUseCase')[0].innerText)">?</button> 
<select id="taskSplitTypeDropdown" onchange="optionChanged_howBigSpecific(this,'bigtaskoption');">
	<option>&nbsp;</option>
	<option value="needsSubRequirements">requirement</option>	
	<option value="needsUseCase">simple use case</option>	
</select><br><br>
<div id="divForWhatIsASimpleUseCase">  
A 'simple use case' starts with an 'event' like a user clicking a button, application starting etc.<br>
Based on some condition, a sequence of steps are performed.<br>
Whereas, a 'requirement' can be broken down into sub-requirements and eventually, 'simple use cases'.
</div>

<div class="bigtaskoption" id="needsSubRequirements">
<div id="firstSubrequirementDiv" style="display:block;background:#f0ddf0">
First sub-requirement/use case<br> 
<script>
$(function(){appendVisibleElementClone("firstSubrequirementDiv","summAndDesc")})
</script>
</div>
<br><br>
<div id="secondSubrequirementDiv" style="display:block;background:#e0ddf0">
Second sub-requirement/use case<br>
<script>
$(function(){appendVisibleElementClone("secondSubrequirementDiv","summAndDesc")})
</script>
</div>
</div><!-- needsSubRequirements -->

<div class="bigtaskoption" id="needsUseCase">
<!--Object/UI element that raises the event (e.g. 'Application') (pseudo-code or imaginary names are ok!) <input type="text"><br>-->
<!-- Commenting out the name to keep it simple, the event name will indicate!-->
Name of event  (e.g. 'Application Start', 'Click on button X of screen Y') <input type="text"><br>
<div id="divforconditiondetectionfn" style="display:block !important; background:#eeeeee;">
<b>Use Case condition</b><br>
<script>
	$(function()
	{
		appendVisibleElementClone("divforconditiondetectionfn", "newfndetails");
		var idofclonedele = replacements["fnreturntype"];
		//console.log("idofclonedele="+idofclonedele);
		var fnReturnTypeTextbox = $("#"+idofclonedele)[0];
		fnReturnTypeTextbox.value = "boolean (will return 'true' or 'false')";
		fnReturnTypeTextbox.readOnly = true;
		fnReturnTypeTextbox.style.backgroundColor = "#eeeeee";
	});
</script>
</div>
<div id="divforexecutionfn" style="display:block !important; background:#ddddee;">
<b>Use case action</b><br>
<script>
$(function(){appendVisibleElementClone("divforexecutionfn","newfndetails")})
</script>
</div>
</div>

</div><!-- divfortaskthatdoesnotspecifycreationofafunction -->


<div id="summAndDesc" class="classForDivForOptionForReqOrUseCase">
	Summary<button 
	onclick="copyFromTaskSummary($('#subtasksummary')[0]);"
	>Paste parent task's summary as starting point</button><br> 
	<input id="subtasksummary" type="text" size="120"><br>
	<br>
	Description<button 
	onclick="copyFromTaskDesc($('#subtaskdesc')[0]);"
	>Paste parent task's description as starting point</button><br> 
	<textarea id="subtaskdesc" rows="5" cols="120"></textarea><br>	
Note: This child task's summary and description must be enough to clearly and completely describe the task.<br> 
There should be no need to refer to the parent task's details, sibling task's details, or any other task or diagram.<br>
Unwanted details that should be part of the other child task, must not be present in the summary and description of this child task.<br>
</div><!-- end summAndDesc -->


<div id="returnconstantornewfn"> 
Does the value to be returned just need to be a constant? <select 
id="optiontoreturnconstantorcallfn" onchange="showDivForCurrentlySelectedOption(this,'classForDivForReturnConstantOrNewFn')">
<option >&nbsp;</option>
<option value="divToReturnConst">Yes</option>
<option value="divToReturnValueOfAFncall">No</option>
</select><br><br>

<div id="divToReturnConst" class="classForDivForReturnConstantOrNewFn">
<script>$(function(){appendVisibleElementClone("divToReturnConst", "returnConstant")})</script>
</div>

<div id="divToReturnValueOfAFncall" class="classForDivForReturnConstantOrNewFn" style="background:#9999ff">
<script>$(function(){appendVisibleElementClone("divToReturnValueOfAFncall", "newfndetails")})</script>
</div>

</div><!-- end of div returnconstantornewfn -->



<div id="newfndetails"> 
Describe the function (sequence of steps) to be called:<br>
Name <input type=text size="30"><br> 
Type of Data Returned (String, Number, Map of keys and values etc.) <input type=text size="30" id="fnreturntype"> <!--Description <input type=text size="90">--> <br> 
<!--File Name  </pre><input type=text size="30"><pre> --->
<!-- Let us have user defined functions as parameterless otherwise difficult to maintain binary work breakdown!
Parameter 1 <input type=text size="30"> Type <input type=text size="30"> Description <input type=text size="60"> <br> 
Parameter 2 <input type=text size="30"> Type <input type=text size="30"> Description <input type=text size="60"> <br> 
Parameter 3 <input type=text size="30"> Type <input type=text size="30"> Description <input type=text size="60"> <br>-->
<br> 
Description  <br>
<textarea rows="5" cols="120"></textarea><br>
<br>
Note the following:<br>
1. The function description must be enough to clearly and completely describe the task, without needing to refer to any other task or diagram.<br>
2. You do not have to write code inside the description of the above function. Just clearly describe what the function does.<br> 
The function will be broken into 2 parts by a crowd member as a part of another task. You will only need to review the break-down.<br>
3. The SPOCs will decide whether you have described a new, existing or ready-made function. They will decide the actual line of code.<br><br>
</div>


<div id="returnConstant" style="background:#dddddd">
Enter value of the constant <input><br>
Enter the reason for choosing this constant, any other possible values it might change to etc.<br>
<textarea id="reasonForChoosingConst" rows="5" cols="120"></textarea><br>
</div>

<!-- TESTING: This comment should not show up in the text to reply with -->
</div><!-- divThatCreatesTheTextToReplyWith -->
<br>
<button id="btnToshowNextSteps" style="display:none;" 
onclick="showNextSteps();">Next...</button>
<div id="divForNextSteps" style="display:none">
<br>
<b id="nextStepsCaption">Next steps</b><br><br> 

1.  Reply to all, keeping the subject of the mail the same. Mail the text in the textarea below.<br> 
If you have edited the input fields after clicking the 'Next'button, ensure that you click the 'Next' button again:<br>
<textarea id="textToReplyWith" rows="10" cols="120" style="background:#eeffee;"></textarea><br><br>
<pre>
2. Once the task creator has reviewed and agreed on the task breakdown:	
	a) The code reuse SPOC identified for this project, will review and integrate the pseudo-code that you created for this task.
	c) If you broke this task into subtasks that need to be further crowdsourced, a SPOC will create new tasks in the crowdsourcing vendor's task tracker. 
	This SPOC will then send emails to crowd members who have requested work, to break down these subtasks. 

3. Once other members of the crowd start work on further breaking down these new tasks, you must act as the reviewer for these 2 breakdowns.

You can now proceed to break down other tasks assigned to you. Make sure to reserve enough time for review and rework.

</pre><b style="color:red;">Important</b><pre> 
In case of closed-source development projects: 
Do not reveal the details of any task assigned to you or created by you to anyone, except of course to:
- the reviewer (in case you are assigned to break down the task) 
- the reviewee (in case you are the reviewer)
- the designated crowd interaction SPOC of your project			   
Violation of the above will lead to financial loss for yourself, the other crowd members, your customer and organization and may be a punishable legal offence.
In case of any mistakes, you have to correct the summary and description of the tasks you created, and get it re-reviewed by your reviewer.

</pre>
</div>
<script>

//At startup, ensure that all buttons are of type 'button'.
$(function()
{
 $(":button" ).prop("type", "button"); 
 $("textarea").prop("maxlength","2000")
 $("#textToReplyWith").prop("maxlength","10000")
 $(':text').prop("maxlength", "150")
 setupDisplayOfNumOfCharsTypedAndCharLimit() 
})
</script>
</body>
</html>
