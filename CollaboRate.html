<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>
		CollaboRate v1.3 - Work Binary Breakdown Structure (WBBS) Tool for Crowdsourced IT
	</title>
	<!-- 
	Project website: https://github.com/sohrabsaran/CollaboRate	
	Copyright Sohrab Saran (sohrabsaran@gmail.com) and additional contributors listed at https://github.com/sohrabsaran/CollaboRate/wiki/Contributors
	License type: MIT	
	-->
	<link rel="stylesheet" type="text/css" href="3rdPartyLibs/css/jquery-ui_1.12.0.css">
	<style>
		* {font-family: Sans-Serif;}
		pre 
		{
			display:inline;
			white-space: pre-wrap;       /* css-3 */
			white-space: -moz-pre-wrap;  /* Mozilla, since 1999 */
			white-space: -pre-wrap;      /* Opera 4-6 */
			white-space: -o-pre-wrap;    /* Opera 7 */
			word-wrap: break-word;       /* Internet Explorer 5.5+ */
		}

		div
		{			
			padding-left: 5px;/*so that nested divs can be visualized*/
		}
		
		input[type=text]
		{
			width:100%;
			max-width:875px;
		}
		
		/*for blocking input until the server responds*/
		.divThatBlocksInput 
		{
			position: fixed;
			z-index: 999;
			top: 0px;
			left: 0px;
			width: 100%;
			height: 100%;
			background-color: black;
			opacity: 0.5;
			color: white;
			text-align:center;
		}
	</style>
	
	<!--
	<script
		src="https://code.jquery.com/jquery-3.1.1.slim.min.js"
		integrity="sha256-/SIrNqv8h6QGKDuNoLGA4iret+kyesCkHGzVUUV0shc="
		crossorigin="anonymous">
	</script>
	--->
	<script src="3rdPartyLibs/js/jquery-3.2.1.min.js"></script>
	<!--<script src="3rdPartyLibs/js/jquery-ui.min.1.12.0.js"></script>-->	
	<script src="3rdPartyLibs/js/jquery-ui.min.1.12.0.js"></script>
	<script src="3rdPartyLibs/js/jquery.fix.clone.js"></script>
	<script>
	
var pageDisabledCtr = 0;
var dbgEnableDisablePage = false;

//Disable the entire page with opacity of 50%.
//Preferable to call disablePageAndSleep because some browsers such as chrome do not 
//immediately update the UI? TODO: prepare the code to be async
function disablePage(reasonForDisablingThePage)
{	
	assert(pageDisabledCtr >= 0);
	//alert("In disablePage()...");
	pageDisabledCtr++;
	if(dbgEnableDisablePage){console.log("Disabling the page to "+reasonForDisablingThePage+", now pageDisabledCtr has increased to "+pageDisabledCtr+"...");}
	if(pageDisabledCtr == 1)
	{
		$("body").prepend("<div class='divThatBlocksInput'>Please wait...</div>");
	}
}

//Remove the divThatBlocksInput which further enables the page for the user.
function enablePage(reason)
{
	assert(pageDisabledCtr > 0);
	pageDisabledCtr--;
	if(dbgEnableDisablePage){console.log("Enabling page: reason: "+reason+" is complete, now pageDisabledCtr has reduced to "+pageDisabledCtr+"...");}
	if(pageDisabledCtr == 0){$(".divThatBlocksInput").remove();}
	//alert("re-enabled the page!");
}
	
function custom_alert(output_msg, title_msg, fnToCallOnClose)
{
    if (!title_msg){title_msg = '';}
	
	title_msg = capitalizeFirstLetter(title_msg);

    if (!output_msg)
	{
        output_msg = '(No Message to Display!)';
	}
	output_msg=output_msg.replaceAll("\r\n","\n").replaceAll("\n","<BR>");

	var emptyDiv = $("<div style=\"background:white;overflow:auto;\"></div>");
    emptyDiv.html(output_msg);
	var h = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
	h  = h * 70/100;
	emptyDiv.dialog({
        "title": title_msg,
        "resizable": true,
        "modal": true,
		"width": "70%",
		/** /height:h,/ **/
        "buttons": {
            "Ok": function()
            {
                $( this ).dialog( "close" );
            }
        },
		"close": function(){if(fnToCallOnClose != null){fnToCallOnClose();}emptyDiv.remove();}
    });	
	if(emptyDiv[0].offsetHeight > h)
	{
		emptyDiv[0].style.height = parseInt(h,10)+"px";		
	}
}

function capitalizeFirstLetter(s) 
{
	if(s == "" || s == null){return s;}
    return s.charAt(0).toUpperCase() + s.slice(1);
}

//lcsset begin
var lcssetcache, uniquestr, uniquectr

function lcsset(a,b)
{
	//p("sdfsdf")
	lcssetcache = {}	
	inituniquestr(a,b)
	return lcsset2(a,b)
}

function inituniquestr(a,b)
{
	uniquectr = 0
	inituniquestr2(a)
	inituniquestr2(b)
	//p("uniquestr='"+uniquestr+"'")
}

function inituniquestr2(a)
{
	while(1)
	{
		uniquestr = "" + uniquectr
		if(a.indexOf(uniquestr) == -1){break}
		uniquectr++
	}
}

function lcsset2(a, b)
{
	var r = lcsset2_1(a, b)
	//p("lcsset2(): a='"+a+"', b='"+b+"', r="+JSON.stringify(r))
	return r
}

function lcsset2_1(a, b)
{	
	var k = a + uniquestr + b
	if(k in lcssetcache){return lcssetcache[k]}
	var r = lcsset3(a,b)
	lcssetcache[k] = r
	return r
}

function lcsset3(a, b)
{
	//var dbg = (a=="c" && b == "cd")
	if(a.length == 0 || b.length == 0){return [""]}
	if(a.charAt(0) == b.charAt(0))
	{	
		if(a.length == 1 && b.length == 1)
		{
			return [a]
		}
		var firstChr = a.charAt(0)		
		var r2 = []
		var r = lcsset2(a.substring(1),b.substring(1))
		assert(r.length > 0)
		r.forEach(function(s){r2.push(firstChr+s)})				
		return r2
	}
	var r1 = lcsset2(a,b.substring(1))
	assert(r1.length > 0)
	var r2 = lcsset2(a.substring(1),b)
	assert(r2.length > 0)
	if(r1[0].length == 0){return r2}
	if(r2[0].length == 0){return r1}
	if(r1[0].length == r2[0].length)
	{
		r2.forEach(function(r2ele){if(r1.indexOf(r2ele) == -1){r1.push(r2ele)}})	
		return r1
	}
	if(r1[0].length > r2[0].length){return r1}	
	return r2
}
//lcsset end

//diff logic start
var bestdiffs, bestnumofdiffs,bestdiffstartingpoint

function diff(old,neww)
{
	bestdiffs=[]
	var setoflcses = lcsset(old,neww)
	//console.log("diff(): setoflcses.length="+setoflcses.length)
	setoflcses.forEach(function(lcs){		
		findandaccumbestdiffsfor(lcs,old,neww)})
	assert(bestdiffs.length>0)
	return bestdiffs[0]
}

function findandaccumbestdiffsfor(lcs, old, neww)
{	
	var r = findbestdiffsfor2(lcs, old, neww)
	//console.log("findandaccumbestdiffsfor(): lcs='"+lcs+"',old='"+old+"',neww='"+neww+"',r="+JSON.stringify(r))
	r.forEach(function(diff){updatebestdiffs(diff,bestdiffs)})
	//console.log("findandaccumbestdiffsfor(): At exit, bestdiffs="+JSON.stringify(bestdiffs))
}

function updatebestdiffs(diff,bestdiffs)
{
	if(bestdiffs.length == 0 || isxbetterdiffthany(diff,bestdiffs[0]))
	{
		bestdiffs.push(diff)
		return
	}
	if(isxasgoodadiffasy(diff,bestdiffs[0]))
	{
		bestdiffs.push(diff)
	}
}

function isxasgoodadiffasy(diffx, diffy)
{
	if(diffx.length != diffy.length){return false}
	if(diffx.length == 0){return true}
	var firstdiffofx = diffx[0]
	var firstdiffofy = diffy[0]
	if(firstdiffofx.changetype != firstdiffofy.changetype){return false}
	return (firstdiffofx.str.length == firstdiffofy.str.length)
}

function isxbetterdiffthany(diffx, diffy)
{
	if(diffx.length != diffy.length){return diffx.length < diffy.length}
	if(diffx.length == 0){return false}
	
	var firstdiffofx = diffx[0]
	var firstdiffofy = diffy[0]
	if(firstdiffofx.changetype != firstdiffofy.changetype)
	{
		if(firstdiffofx.changetype == "same"){return true}
		if(firstdiffofy.changetype == "same"){return false}		
	}
	return (firstdiffofx.str.length < firstdiffofy.str.length)
}

function findbestdiffsfor2(lcs, old, neww)
{	
	//console.log("findbestdiffsfor2(): Entry: lcs='"+lcs+"',old='"+old+"',neww='"+neww+"'...")
	var r = findbestdiffsfor3(lcs, old, neww)
	//console.log("findbestdiffsfor2(): lcs='"+lcs+"',old='"+old+"',neww='"+neww+"', r="+JSON.stringify(r))
	return r
}
	
function findbestdiffsfor3(lcs, old, neww)
{
	var dbg = false//(lcs==" saran" && old == "ajiv saran" && neww == "oz saran") || (lcs=="n" && old == "n" && neww == "n")
	if(lcs.length == 0)
	{		
		var r = []		
		if(old.length != 0)
		{
			r.push({str:old,changetype:"deleted"})
		}
		if(neww.length != 0)
		{
			r.push({str:neww,changetype:"added"})
		}
		return [r]
	}
	assert(old.length >= lcs.length)
	assert(neww.length >= lcs.length)
	var allpossibleoldprefixes  = allpossibleprefixesbeforelcs(old,lcs)	
	if(dbg)
	{
		p("allpossibleoldprefixes='"+JSON.stringify(allpossibleoldprefixes)+"'")
	}
	var allpossiblenewprefixes  = allpossibleprefixesbeforelcs(neww,lcs)
	if(dbg)
	{
		p("allpossiblenewprefixes='"+JSON.stringify(allpossiblenewprefixes)+"'")
	}
	var remaininglcs = lcs.substring(1)
	var r = []
	allpossibleoldprefixes.forEach(function(oldprefix)
	{
		if(dbg)
		{
			p("oldprefix='"+oldprefix+"'")
		}
		var remainingold = old.substring(oldprefix.length+1)
		if(dbg)
		{
			p("remainingold='"+remainingold+"'")
		}
		allpossiblenewprefixes.forEach(function(newprefix)
		{
			if(dbg)
			{
				p("newprefix='"+newprefix+"'")
			}
			var remainingnew = neww.substring(newprefix.length+1)
			if(dbg)
			{
				p("remainingnew='"+remainingnew+"'")
			}			
			var deletedchange = null
			if(oldprefix!="")
			{
				deletedchange = {str:oldprefix,changetype:"deleted"}
			}
			var addedchange = null
			if(newprefix!="")
			{
				addedchange = {str:newprefix,changetype:"added"}
			}			
			var bestremainingdiffs = findbestdiffsfor2(remaininglcs,remainingold,remainingnew)
			if(dbg)
			{
				p("remaininglcs='"+remaininglcs+"',remainingold='"+remainingold+"',remainingnew='"+remainingnew+"'")
				p("bestremainingdiffs="+JSON.stringify(bestremainingdiffs))
			}
			bestremainingdiffs.forEach(function(bestremainingdiff)
			{
				if(bestremainingdiff.length > 0 && bestremainingdiff[0].changetype=="same")
				{
					bestremainingdiff[0].str = lcs.substring(0,1) + bestremainingdiff[0].str
				}
				else
				{
					bestremainingdiff.unshift({str:lcs.substring(0,1),changetype:"same"})
				}
				if(addedchange != null){bestremainingdiff.unshift(addedchange)}
				if(deletedchange != null){bestremainingdiff.unshift(deletedchange)}
				if(dbg)
				{
					p("bestremainingdiff="+JSON.stringify(bestremainingdiff))
				}
				if(dbg)
				{
					p("Before updatebestdiffs(), bestremainingdiff=" + JSON.stringify(bestremainingdiff) + ", r=" + JSON.stringify(r))
				}
				updatebestdiffs(bestremainingdiff,r)
				if(dbg)
				{
					p("After updatebestdiffs(), r="+JSON.stringify(r))
				}
			})			
		})
	})
	return r
}

function allpossibleprefixesbeforelcs(s,lcs)
{
	var r = allpossibleprefixesbeforelcs2(s, lcs)
	//console.log("allpossibleprefixesbeforelcs(): s='"+s+"', lcs='"+lcs+"', return value="+JSON.stringify(r))
	return r
}

function allpossibleprefixesbeforelcs2(s,lcs)
{
	assert(lcs.length > 0)
	assert(s.length >= lcs.length)
	assert(containslcs(s,lcs))	
	var lens = s.length
	var r = []
	var firstcharoflcs = lcs.substring(0,1)
	for(var i=0;i<lens;i++)
	{
		i = s.indexOf(firstcharoflcs,i)
		if(i==-1){return r}
		var s2 = s.substring(0,i)
		var remainings = s.substring(s2.length)
		if(!containslcs(remainings,lcs))
		{			
			return r
		}		
		r.push(s2)
	}
	return r
}

function containslcs(s,lcs)
{
	while(1)
	{
		if(lcs==""){return true}
		var lcsfirstchar = lcs.substring(0,1)
		var i = s.indexOf(lcsfirstchar)
		if(i==-1){return false}
		lcs = lcs.substring(1)
		s = s.substring(i+1)
	}
}
//diff logic end

//shortcut for document.getElementById or for ($("#"+eleid)[0]))
function el(eleid){return document.getElementById(eleid)}

//Shows the div for the currently selected option
function showDivForCurrentlySelectedOption(drpdn)
{
	var dbg = false;
	if(dbg)
	{
		console.log("showDivForCurrentlySelectedOption(): drpdn="+drpdn.outerHTML);
		console.log("showDivForCurrentlySelectedOption(): drpdn="+drpdn.outerHTML);		
		console.log("showDivForCurrentlySelectedOption(): drpdn.value (id of div to make visible) = '"+drpdn.value+"'");
	}	
	$(drpdn).find("option").each(function() {if(this.value!="")$("#"+this.value).hide()})
	
	if(drpdn.value.trim() != "")
	{
		//origAlert("drpdn.value='"+drpdn.value+"'")
		$("#"+drpdn.value).show();
		if($("#"+drpdn.value).find("select:visible").length == 0)
		{		
			showNextStepsButton()
		}
		else
		{	
			hideNextStepsButton()
		}
	}
	else
	{	
		hideNextStepsButton()
	}
	if(drpdn.value == "needtogetapprovalmsgdiv")
	{
		hideNextStepsButton()
	}
	if(dbg)
	{
		console.log("showDivForCurrentlySelectedOption(): now check whether the element with id '"+drpdn.value+"' has been made visible.");
		console.log("showDivForCurrentlySelectedOption(): number of elements with id '"+drpdn.value+"' are "+$("#"+drpdn.value).length);
	}
}

function showNextStepsButton()
{
	$("#btnToShowNextSteps").show();
}

function hideNextStepsButton()
{
	$("#btnToShowNextSteps").hide();
}

var eleIdsDifferentiator = 0;
var replacements;

String.prototype.replaceAll = function(search, replacement) {
    var target = this;
    return target.replace(new RegExp(search, 'g'), replacement);
};

var dbgWithIdsMadeDifferent = false;

//returns a string of the outerHTML of the specified eleId but all all ids and reference to those ids made different.
function withIdsMadeDifferent(eleId)
{
	if(dbgWithIdsMadeDifferent)
	{
		console.log("withIdsMadeDifferent(): On entry, eleId='"+eleId+"', ($(\"#\"+eleId)[0]).outerHTML='"+($("#"+eleId)[0]).outerHTML+"'...");
	}
	var s = withIdsMadeDifferentButNotReferencesToThem(($("#"+eleId).clone(true,true))[0]).outerHTML;
	if(dbgWithIdsMadeDifferent)
	{
		console.log("withIdsMadeDifferent(): After withIdsMadeDifferentButNotReferencesToThem(), eleId='"+eleId+"', s='"+s+"'...");
	}
	for (var key in replacements)
	{
		if(dbgWithIdsMadeDifferent)
		{
			console.log("withIdsMadeDifferent(): string to replace = '"+key+"', replacement = '"+replacements[key]+"'");
		}
		s = s.replaceAll(key,replacements[key]);
		if(dbgWithIdsMadeDifferent)
		{
			console.log("withIdsMadeDifferent(): Now s='"+s+"'...");
		}
	}
	if(dbgWithIdsMadeDifferent)
	{
		console.log("withIdsMadeDifferent(): On exit, s='"+s+"'...");
	}
	return s;
}

function withIdsMadeDifferentButNotReferencesToThem(ele)
{	
	withIdsMadeDifferentButNotReferencesToThemInit()
	withIdsMadeDifferentButNotReferencesToThemLoop(ele);
	return ele;
}

function withIdsMadeDifferentButNotReferencesToThemInit()
{
	eleIdsDifferentiator++
	replacements = {}
}

function withIdsMadeDifferentButNotReferencesToThemLoop(ele)
{
	if(ele.id != null && ele.id != "")
	{
		var oldEleId = ele.id;
		
		//this will prevent double-replacement of the oldEleId:
		ele.id = ele.id.substring(0,1) +eleIdsDifferentiator + ele.id.substring(1);
		
		replacements[oldEleId] = ele.id;
	}	
	var cn = ele.childNodes;
	for(var i=0;i<cn.length;i++)
	{
		withIdsMadeDifferentButNotReferencesToThemLoop(cn[i]);
	}	
}

function copyFromTaskSummary(destinationTextbox)
{	
	destinationTextbox.value = ($("#taskSummary")[0]).value + destinationTextbox.value;
}

function copyFromTaskDesc(destinationTextbox)
{		
	//console.log("destinationTextbox.outerHTML="+destinationTextbox.outerHTML)
	destinationTextbox.value = ($("#taskDesc")[0]).value + destinationTextbox.value;
}

function getTextOfNode(n)
{
	//console.log("gettextofnode: entry");
	if(!($(n).is(':visible'))){return ""}
	if($(n).is(':hidden')){return ""}
	if(n.tagName=="BUTTON"){return ""}
	if(n.tagName=="SELECT")
	{
		//console.log(n.outerHTML)
		var r = n.options[n.selectedIndex].text
		//console.log("For select, returning '"+r+"'...")
		return r
	}
	if(n.childNodes.length==0)
	{
		if(n.text!=undefined){return n.text;}
		if(n.value!=undefined){return n.value;}
	}
	var t = "";
	//console.log("Getting ")
	$(n.childNodes).each(function()
	{
		//console.log("this="+this.outerHTML);
		t+= getTextOfNode(this);
	});
	//console.log("n.outerText='"+n.outerText+"', n='"+n.outerHTML+"', n.innerText='"+n.innerText+"'");
	return t;
}

var dbg_getTextToReplyWith_uniquectr 

function getTextToReplyWith()
{
	var ele = $('#divThatCreatesTheTextToReplyWith')[0];
	dbg_getTextToReplyWith_uniquectr = 0
	return getTextToReplyWithFrom(ele,0)
}

function getTextToReplyWithFrom(ele,indentationLevel)
{
	var dbg = false	
	if(dbg)
	{
		dbg_getTextToReplyWith_uniquectr++
		var dbgmyid = dbg_getTextToReplyWith_uniquectr
	}
	//console.log("ele.outerHTML = "+ele.outerHTML)
	//console.log("ele.innerText = "+ele.innerText)
	//console.log("ele.textContent = "+ele.textContent)
	//return ele.innerText
	//if(!($(ele).is(':visible'))){return ""}
	if((ele.tagName=="DIV" || ele.tagName=="SPAN") && getComputedStyle(ele).getPropertyValue("display") == "none"){return ""}	
	if(ele.tagName=="SCRIPT"){return ""}
	if(ele.tagName=="BUTTON"){return ""}
	if(ele.tagName=="BR"){return "\n"}
	if((ele.tagName == "INPUT" && ele.type == "text") || (ele.tagName == "TEXTAREA"))
	{
		return ele.value
	}
	if(ele.tagName=="SELECT")
	{
		return ele.options[ele.selectedIndex].text
	}
	var s = ""	
	if(ele.nodeType == 3)
	{		
		var r = ele.nodeValue.trim()//trims whitespaces and not just spaces!
		if(r != ele.nodeValue){return r + " "}
		return r
	}
	var indent, ctr, dbgmyid;
	if(dbg)
	{
		ctr=0
		indent = "    ".repeat(indentationLevel)
		s+=indent+"START dbgmyid="+dbgmyid+", tagName="+ele.tagName+",nodeType="+ele.nodeType+"\n"
	}
	$(ele).contents().each(function(){
		if(dbg)
		{			
			s+=indent+"dbgmyid="+dbgmyid+", ele at idx "+ctr+":\n"
			s+=getTextToReplyWithFrom(this,indentationLevel+1)
			s+="\n"+indent+"dbgmyid="+dbgmyid+", end ele at idx "+ctr+"\n";
			ctr++
		}
		else
		{
			s+=getTextToReplyWithFrom(this,indentationLevel+1);
		}
	});
	if(dbg)
	{
		s+=indent+"END dbgmyid="+dbgmyid+", tagName="+ele.tagName+",nodeType="+ele.nodeType+"\n"
	}
	return s;
}

function escapeRegExp(str) 
{
    return str.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
}

String.prototype.replaceAll = function(search, replacement) 
{
    var target = this;
    return target.replace(new RegExp(escapeRegExp(search), 'g'), replacement);
}

function showNextSteps()
{
	($("#textToReplyWith")[0]).value = getTextToReplyWith()
	$("#divForNextSteps").show();	
	window.scrollTo(0,$('#nextStepsCaption').offset().top);	
}

function isValidEleId(id)
{
	return (document.getElementById(id ) != null)
}

function assert(b)
{
	if(!b){throw new Error("Assertion failed");}
}

var gldbg = false;

function appendVisibleElementClone(parentEleId,childEleId)
{
	assert(isValidEleId(parentEleId))
	assert(isValidEleId(childEleId))
	var wasVisible = $("#"+childEleId).is(":visible");
	if(!wasVisible)
	{
		$("#"+childEleId).show();
	}
	var cch = withIdsMadeDifferent(childEleId)
	if(gldbg){console.log(cch)}
	$("#"+parentEleId).append(cch);	
	if(!wasVisible)
	{
		$("#"+childEleId).hide();
	}
}

function setupDisplayOfNumOfCharsTypedAndCharLimit(container)
{
	//console.log("In setupDisplayOfNumOfCharsTypedAndCharLimit(container)...")
    var eles = null;
    //assert(document.forms.length==1);
    //eles = $(document.forms[0].elements);
	eles = $(":input");
	//console.log("eles.length=" + eles.length)
    /**/if(container != null)
    {
        eles = eles.filter(function(index,ele)
        {
            return $.contains(container,ele);
        });
    }/**/
	//console.log("Now eles.length=" + eles.length)
    eles.each(function()
    {
		//console.log("hmmm")
        var ele = this;
        if(ele.maxLength == null || ele.maxLength <= 0 || ele.maxLength == 2147483647){return;}
		//console.log("Applying remaining char count display to '"+ele.outerHTML+"'...")
        ele.style.display ="inline";
        $(ele).focusin(showNumOfCharsTypedAndCharLimit);
        $(ele).focusout(hideNumOfCharsTypedAndCharLimit);
    });
}

function showNumOfCharsTypedAndCharLimit()
{
    //console.log("showNumOfCharsTypedAndCharLimit(): Entry....");
    var textEle = this;
    var textEleIdOrName = textEle.id//getEleIdOrName(textEle);
    var spanId = "SpanIdForNumOfCharsTypedAndCharLimitFor"+textEleIdOrName;
    $(textEle).after("<span id=\""+spanId+"\" style=\"display:inline !important;white-space:nowrap;font-size:smaller;\"></span>");
    $(textEle).keyup(function(){
        //console.log("showNumOfCharsTypedAndCharLimit(): keyup handler....");
        $("#"+spanId)[0].innerText = textEle.value.length + "/"+textEle.maxLength+" chars";
        //console.log("Updated the innerText variable for span with id '"+spanId+"' to '"+$("#"+spanId)[0].innerText+"'");
    });
    $(textEle).keyup();
}

function hideNumOfCharsTypedAndCharLimit()
{
    var textEle = this;
    //console.log("hideNumOfCharsTypedAndCharLimit(): Entry....");
    var textEleIdOrName = textEle.id//getEleIdOrName(textEle);
    var spanId = "SpanIdForNumOfCharsTypedAndCharLimitFor"+textEleIdOrName;
    $("#"+spanId).remove();
}

function imFamiliarToggled(checkbox)
{
	inCaseImFamiliarChecked(checkbox)
	inCaseImFamiliarUnchecked(checkbox)
}

function reversedKeysAndValues(m)
{
	var r = {}
	for(var k in m){r[m[k]]=k}
	return r
}


var mapOfProgrammerTermsToNonProgrammerTerms = {
"functions":"computer activities",
"function":"computer activity",
"Function":"Computer activity",
"requirements":"tasks that mention more than one event",
"requirement":"task that mentions more than one event",
"simple use cases":"tasks that mention a single event",
"simple use case":"task that mentions a single event",
"returned":"output",
" return ":" output ",
"argument":"input",
"String":"Text",
"Map":"Set",
"keys and values":"values accessible by unique names",
"boolean":"'true' or 'false'",
"calling":"running",
"builtin":"readymade",
"a string":"text",
"element":"item",
"array":"list",
"session variable":"something that is remembered as long as the user is logged in",
"variable":"something that can be quickly remembered",
"database":"permanent memory",
"Set value of":"Memorize",
"Get value of":"Remember"
}
var mapOfNonProgrammerTermsToProgrammerTerms = reversedKeysAndValues(mapOfProgrammerTermsToNonProgrammerTerms)

function inCaseImFamiliarChecked(checkbox)
{
	if(checkbox.checked)
	{
		return handleImFamiliarChecked()
	}
}

function handleImFamiliarChecked()
{
	mapToUseForTerminologyChange = mapOfNonProgrammerTermsToProgrammerTerms
	doTerminologyChange()
}

function inCaseImFamiliarUnchecked(checkbox)
{
	if(!(checkbox.checked))
	{
		return handleImFamiliarUnchecked()
	}
}

var mapToUseForTerminologyChange
function handleImFamiliarUnchecked()
{
	mapToUseForTerminologyChange = mapOfProgrammerTermsToNonProgrammerTerms
	doTerminologyChange()
}

function doTerminologyChange()
{
	//console.log("doTerminologyChange(): entry")
	var html = ($("#divThatCreatesTheTextToReplyWith")[0]).innerHTML	
	var m = mapToUseForTerminologyChange
	var div = $("#divThatCreatesTheTextToReplyWith")[0]
	for(k in m)
	{	
		assert(html.replaceAll != null)
		replaceAllOccurencesOfXWithYInHtmlEleZ(k, m[k], div)
	}	
	//console.log("doTerminologyChange(): exit")
}

function replaceAllOccurencesOfXWithYInHtmlEleZ(x,y,z)
{
	if(z.tagName == "SCRIPT"){return}
	if(z.tagName == "INPUT" && (z.type == "hidden" || (z.type == "text" && z.readOnly)))
	{
		z.value = z.value.replaceAll(x,y)
		//console.log("x='"+x+"',y='"+y+"',z.value="+z.value)
	}
	if(z.nodeType == 3)
	{
		z.nodeValue = z.nodeValue.replaceAll(x,y)
	}
	$(z).contents().each(function()
	{
		replaceAllOccurencesOfXWithYInHtmlEleZ(x,y,this)
	})
}


function markAsWizardDropdown(drpdn)
{
	//Initially hide all options
	$(drpdn).find("option").each(function() {if(this.value!="")$("#"+this.value).hide()})
	
	drpdn.onchange=function(){
	showDivForCurrentlySelectedOption(drpdn);
	window.scrollTo(0,document.body.scrollHeight);
	($(":focus")[0]).scrollIntoView();
	}
}

//arr = array-like od dropdown eles
function markAsWizardDropdowns(arr)
{
	Array.from(arr).forEach(function(ele){markAsWizardDropdown(ele)})
}

function htmlfordiffwithparenttaskdesc(newdesctextarea)
{	
	var neww = newdesctextarea.value
	var old = ($("#taskDesc")[0]).value
	var d = diff(old,neww)
	var s= "<div>"
	d.forEach(function(change)
	{		
		if(change.changetype=="added")
		{
			s+="<pre style=\"background:#ddffdd\">"+change.str+"</pre>"
		}
		else if(change.changetype=="deleted")
		{
			s+="<pre style=\"background:#ffdddd;text-decoration:line-through\">"+change.str+"</pre>"
		}
		else
		{
			assert(change.changetype=="same")
			s+="<pre>"+change.str+"</pre>"
		}		
	})
	s += "</div>"
	return s
}

function showdiff(textarea)
{
	custom_alert(htmlfordiffwithparenttaskdesc(textarea),"Comparison with parent task's description");
}

var origAlert = alert
alert = custom_alert
</script>
</head>
<body>
<H2 id="pageheading">
	<script>
		$(function(){$("#pageheading").append(document.title);});
	</script>
</H2>
<div style="text-align:center;display:block !important;"><small>Mostly tested with Mozilla FireFox</small></div>
<a href=# onclick="window.open('https://github.com/sohrabsaran/CollaboRate#collaborate---a-crowdsourcing-process-and-software-tool');return false");">Help</a><br>
<br>
This tool will guide you to break down your assigned task.<br>
<br>
<b>Task Summary</b> <button onclick="alert(el('taskSummary').placeholder)">?</button><br><!--(the phrase 'create function' in summary could be taken as a keyword for some workflow/validations)--> 
</pre><input id="taskSummary" size="120" type="text" 
placeholder="Copy the task summary and paste it here."><!--style="background:#eeeeee"--><pre> 

</PRE><b>Task Description</b> <button onclick="alert(el('taskDesc').placeholder)">?</button> <br>
<textarea rows="5" cols="120" id="taskDesc" placeholder="Copy the task description and paste it here.">
</textarea><!--style="background:#eeeeee;"--><br>
Note: Before you break down this task, check that its description is clear and complete. It must not refer to any other task.<br> 
Otherwise, bring this to the notice of the task sender, and ensure that you receive a clear and complete task description.<br>
<br>
<b style="color:red">Note that you do not need to fully solve this task. Child tasks must be context-free, and differ by logic rather than data.</b> <button type="button" 
onclick="alert(($('#divForExplanationForWhyYouDoNotNeedToFullySolveThisTask')[0]).innerText)">?</button>
<br>
<div id="divForExplanationForWhyYouDoNotNeedToFullySolveThisTask" style="display:none !important">
As per the CollaboRate process, you do not need to fully solve an assigned task.<br>
Your microtask is just to break down this task into 2 parts.<br> 
Both parts usually yield subtasks. <br>
Sometimes the task assigned is so small that it may yield 1 subtask or even no subtask.<br>
Other crowd members will break down the subtasks you create.<br> 
<br>
To do more work, you break down other tasks.<br><br>
In this way we enable many people to work together, and can accurately measure the work done by each person.<br>
<br>												 
Child tasks should be self-contained.<br>
A child task's summary and description must be enough to clearly and completely describe the task.<br> 
There should be no need to refer to the parent task's details, sibling task's details, or any other task.<br>
Unwanted details that should be part of the other child task, must not be present in the summary and description of this child task.<br>
<br>												 
Tasks must be split, such that the child tasks differ from each other via logic, rather than just different data being passed to same logic.<br>																		 
</div>
<br>
<input type="checkbox" onchange="imFamiliarToggled(this)">I'm familiar with software programming terms and concepts.
<br>
<br>

<!--Though it is hoped that this tool will be used by non-programmers as well, basic understanding of programming concepts is useful.<br>-->

<div id="divThatCreatesTheTextToReplyWith" style="background:#eeeeff;">
<b>Does this task specify the creation of a function?</b> 
<select id="isThisAFnDropdown" class="wizardDropdown">
<option>&nbsp;</option>
<option value="divfortaskthatspecifiescreationofafunction">Yes</option>
<option value="divfortaskthatdoesnotspecifycreationofafunction">No</option>
</select><br><br>

<div id="divfortaskthatspecifiescreationofafunction" style="background:#ffe066;">
(Question applicable for projects where task visibility is unrestricted e.g. experimental or open-source projects. Answer 'yes' if not applicable):<br>
<b> Have permissions to crowdsource this task been given by all the SPOCs (library reuse SPOC, project code reuse SPOC, programming language SPOC etc.) ? </b> 
Contact the SPOCs if you are not sure how permissions are mentioned. 
<select id="isPermissionToCrowdsourceGivenDropdown" class="wizardDropdown"
<!--onchange2="if(this.value=='no'){console.log('You need to get approval before breaking down this task.');}else{;$('#divtoshowforcreationofapprovedfn').show();}"-->
>
<option>&nbsp;</option>
<option value="divtoshowforcreationofapprovedfn">Yes</option>
<option value="needtogetapprovalmsgdiv">No</option>
</select><br><br>

<div id="needtogetapprovalmsgdiv" style="background:#ff4d4d">
This task is not (yet) permitted to be crowdsourced. Contact the SPOCs for further discussion.
</div>

<div id="divtoshowforcreationofapprovedfn" style="background:#eeeeff;" >
<b>What is the best way to break down this function?</b>  
<select id="fnSplitTypeDropdown" class="wizardDropdown">
	<option>&nbsp;</option>	
	<option value="nonObviousReqAndElaboratedNewFn">Break it down into a non-obvious task, and a new task for this function, but with more details.</option>
	<option value="needsSubFns">Break it down into smaller functions.</option>
	<option value="unnecessaryJustNeedsToReturnConstant">This task is unnecessary. This function just needs to return a constant!</option>
</select><br><br>

<div id="unnecessaryJustNeedsToReturnConstant">
<script>
$(function(){appendVisibleElementClone("unnecessaryJustNeedsToReturnConstant", "returnConstant")})
</script>
</div>

<div id="nonObviousReqAndElaboratedNewFn">
<div style="display:block !important;background:#ffeeee;" id="nonObviousReqOrUseCase">
<b>Enter the details for the non-obvious task</b><br><br>
<script>
$(function(){appendVisibleElementClone("nonObviousReqOrUseCase", "summAndDesc")})
</script>
</div><!-- nonObviousReqOrUseCase -->
<pre> 

Enter the more detailed technical description for this new function to be created
</pre>
<script>
$(function(){appendVisibleElementClone("nonObviousReqAndElaboratedNewFn","newfndetails")})
</script>
</div><!-- end div nonObviousReqAndElaboratedNewFn-->

<div id="needsSubFns" style="background:#b3ffff;">
How are the 1-2 new functions joined together? 
<select id="codeblockdropdown" class="wizardDropdown">
<option>&nbsp;</option>
<option value="divtoshowforfncallsequence">Sequence of 2 functions. The return value of this function, is that of the second.</option>
<option value="divtoshowforifsequence">If function1 returns 'true' then return the return value of function2, else return 'false'</option>
<option value="divtoshowforloopsequence">While function1 returns 'true', keep calling function2</option>
<option value="divforcallingbuiltinfn">As arguments to a 2-argument builtin function</value>
</select><br><br>

<div id="divforcallingbuiltinfn">
Select the builtin function to call 
<select id="builtindropdown" class="wizardDropdown">
<option>&nbsp;</option>

<option value="divtogetuserinputfromscreen">Get data entered on a screen, as a string</option>
<!-- 
params:
1. Something that returns the unique name of the screen of the input field
2. Something that returns the unique name of the input field on the screen
-->

<option value="divtogetattrofobjorelofarr">Get attribute of object or element of array</option>
<!-- 
params:
1. something that returns object/array name
2. something that returns attribute name/value of 0-based index
-->

<option value="divtogetsomethingpreviouslymemorized">Get value of variable</option>
<!-- params: 
	1. something that returns the variable name.
-->

<option value="divtogetsomethingpreviouslymemorizedforsession">Get value of session variable</option>
<!-- params: 
	1. something that returns the variable name.
-->

<option value="divtoshowforreadfromdb">Read object(s) from database</option>
<!-- params: 
1. something that returns the table name, (always fetches columns of this table and not of joined table, we will have unique names and mysql enums rather than id,pk,fk etc.)
2. sql select 'where' clause function (filter function) whose return type is boolean - if false then object to check gets filtered out. 
The object to check is already stored in memory with name 'objectToFilter'
So parameters are limited to <=2 for binary WBS
-->

<option value="divtoquicklymemorizesomething">Set value of variable</option>
<!-- store value in a per-thread global variable.  
params (limited to <=2 for binary WBS): 
1  name: something that returns the name by which to memorize the data
2. value: something that returns the object or value to be memorized
-->

<option value="divtomemorizesomethingforthesession">Set value of session variable</option>
<!-- store value in a session variable.  
params (limited to <=2 for binary WBS): 
1  name: something that returns the name by which to memorize the data
2. value: something that returns the object or value to be memorized
-->

<option value="divtoinsnewobjindb">Insert new object in database and return the unique id generated</option>
<!-- 
params:
1. something that returns the object to insert 
2. something that returns the name of the table in which to insert the object
Returns: id of inserted row 
-->

<option value="divforupdatedb">Update existing objects in database</option>
<!-- 
params:
1. function to read objects from database
2. function to modify an object. The object is passed to the function via a memory variable named 'objectToUpdate'
-->

<option value="divtoupdatepropofpartofscreen">Update property of a part of the screen</option>
<!--
params:
1. something to give the name of the part of the screen to update (in format <screen name>_<field name>_<property name>
2. something to give the new value to assign to the property
-->

<option value="divformiscbuiltinfn">Any other miscellaneous builtin function that should exist, having not more than 2 inputs</option>
<!--
params:
1. Something1
2. Something2
-->

</select><br><br>

<div id="divtogetuserinputfromscreen">
<!-- 
Get user input from the screen as a string
params:
1. Something that returns the unique name of the screen of the input field.
2. Something that returns the unique name of the input field on the screen.
-->
<div style="display:block;background:#cce6ff" id="divforscreenname">
<b>Unique name of the screen of the input field</b><br>
<script>$(function(){appendVisibleElementClone("divforscreenname", "returnconstantornewfn")})</script>
</div>
<div style="display:block;background:#b3d9ff" id="divforfieldnameonitsscreen">
<b>Unique name of the input field on its screen</b><br>
<script>$(function(){appendVisibleElementClone("divforfieldnameonitsscreen", "returnconstantornewfn")})</script>
</div>
</div>

<div id="divtogetattrofobjorelofarr">
<!-- 
Get attribute of object or element of array
params:
1. something that returns object/array
2. something that returns attribute name/value of 0-based index
-->
<div style="display:block;background:#cce6ff" id="divforobjorarr">
<b>Object or array</b><br>
<script>$(function(){appendVisibleElementClone("divforobjorarr", "newfndetails")})</script>
</div>
<div style="display:block;background:#b3d9ff" id="divforattrname">
<b>Attribute name of object, or value of the 0-based index</b><br>
<script>$(function(){appendVisibleElementClone("divforattrname", "returnconstantornewfn")})</script>
</div>
</div>

<div id="divtogetsomethingpreviouslymemorized">
<!-- params: 
	1. something that returns the variable name.
-->
<b>Memory Variable name</b><br>
<script>$(function(){appendVisibleElementClone("divtogetsomethingpreviouslymemorized", "returnconstantornewfn")})</script>
</div>

<div id="divtogetsomethingpreviouslymemorizedforsession">
<!-- params: 
	1. something that returns the variable name.
-->
<b>Session Variable name</b><br>
<script>$(function(){appendVisibleElementClone("divtogetsomethingpreviouslymemorizedforsession", "returnconstantornewfn")})</script>
</div>

<div id="divtoshowforreadfromdb">
<!-- 
Read object(s) from database
params: 
1. something that returns the table name, (always fetches columns of this table and not of joined table, we will have unique names and mysql enums rather than id,pk,fk etc.)
2. sql select 'where' clause function (filter function) whose return type is boolean - if false then object to check gets filtered out. 
The object to check is already stored in memory with name 'objectToFilter'
So parameters are limited to <=2 for binary WBS
-->
<div style="display:block;background:#cce6ff" id="divfortablename">
<b>Table Name</b><br>
<script>$(function(){appendVisibleElementClone("divfortablename", "returnconstantornewfn")})</script>
</div>
<div style="display:block;background:#b3d9ff" id="divforfilterfn">
<b>Filter function whose return type is 'true' or 'false' - if false, then the object to check gets filtered out.</b><br>
Note: The object to check will already stored in memory by the builtin function, with name 'objectToFilter'<br>
<script>$(function(){appendVisibleElementClone("divforfilterfn", "newfndetails")})</script>
</div>
</div>

<div id="divtoquicklymemorizesomething">
<!-- store value in a per-thread global variable.  
params (limited to <=2 for binary WBS): 
1  name: something that returns the name by which to memorize the data
2. value: something that returns the object or value to be memorized
-->
<div style="display:block;background:#cce6ff" id="divformemvarnametowriteto">
<b>Unique name of the memory location (variable)</b><br>
<script>$(function(){appendVisibleElementClone("divformemvarnametowriteto", "returnconstantornewfn")})</script>
</div>
<div style="display:block;background:#b3d9ff" id="divfordatatomemorizeinmemvar">
<b>Data to memorize</b><br>
<script>$(function(){appendVisibleElementClone("divfordatatomemorizeinmemvar", "returnconstantornewfn")})</script>
</div>
</div>

<div id="divtomemorizesomethingforthesession">
<!-- store value in a per-thread global variable.  
params (limited to <=2 for binary WBS): 
1  name: something that returns the name by which to memorize the data
2. value: something that returns the object or value to be memorized
-->
<div style="display:block;background:#cce6ff" id="divformemsessionvarnametowriteto">
<b>Unique name of the session memory location (variable)</b><br>
<script>$(function(){appendVisibleElementClone("divformemsessionvarnametowriteto", "returnconstantornewfn")})</script>
</div>
<div style="display:block;background:#b3d9ff" id="divfordatatomemorizeinsessionmemvar">
<b>Data to memorize</b><br>
<script>$(function(){appendVisibleElementClone("divfordatatomemorizeinsessionmemvar", "returnconstantornewfn")})</script>
</div>
</div>

<div id="divtoinsnewobjindb">
<!-- 
Insert new object in database and return the unique id generated
params:
1. something that returns the object to insert 
2. something that returns the name of the table in which to insert the object
Returns: id of inserted row 
-->
<div style="display:block;background:#cce6ff" id="divforobjtoins">
<b>Object to insert</b><br>
<script>$(function(){appendVisibleElementClone("divforobjtoins", "returnconstantornewfn")})</script>
</div>
<div style="display:block;background:#b3d9ff" id="divfornameoftabletoinsinto">
<b>Name of table to insert the object into</b><br>
<script>$(function(){appendVisibleElementClone("divfornameoftabletoinsinto", "returnconstantornewfn")})</script>
</div>
</div>

<div id="divforupdatedb">
<!-- 
Update existing objects in database
params:
1. function to read objects from database
2. function to modify an object. The object is passed to the function via a memory variable named 'objectToUpdate'
-->
<div style="display:block;background:#cce6ff" id="divforfntoreadobjstoupdate">
<b>Function to read objects from database</b><br>
<script>$(function(){appendVisibleElementClone("divforfntoreadobjstoupdate", "newfndetails")})</script>
</div>
<div style="display:block;background:#b3d9ff" id="divforfntoupdatedbobj">
<b>function to modify an object. The object is passed to the function via a memory variable named 'objectToUpdate'</b><br>
<script>$(function(){appendVisibleElementClone("divforfntoupdatedbobj", "newfndetails")})</script>
</div>
</div>

<div id="divtoupdatepropofpartofscreen">
<!--
Update property of a part of the screen
params:
1. something to give the name of the part of the screen to update (in format <screen name>_<field name>_<property name>)
2. something to give the new value to assign to the property
-->
<div style="display:block;background:#cce6ff" id="divfornameofpartofscreentoupdate">
<b>Name of the part of the screen to update (in format &lt;screen name&gt;_&lt;field name&gt;_&lt;property name&gt;)</b><br>
<script>$(function(){appendVisibleElementClone("divfornameofpartofscreentoupdate", "returnconstantornewfn")})</script>
</div>
<div style="display:block;background:#b3d9ff" id="divforvaluetogivetoscreenpart">
<b>Value to assign to the property of the screen part</b><br>
<script>$(function(){appendVisibleElementClone("divforvaluetogivetoscreenpart", "returnconstantornewfn")})</script>
</div>
</div>

<div id="divformiscbuiltinfn">
<!--
Any other miscellaneous builtin function that should exist, having not more than 2 inputs
params:
1. Something1
2. Something2
-->
<div style="display:block;background:#ffb3d9" id="divforfnnameanddescofmiscbuiltinfn">
<script>$(function(){appendVisibleElementClone("divforfnnameanddescofmiscbuiltinfn", "newfndetails")})</script>
</div>
<div style="display:block;background:#cce6ff" id="divforfirstparamofmiscbuiltinfn">
<b>First Parameter</b><br>
<script>$(function(){appendVisibleElementClone("divforfirstparamofmiscbuiltinfn", "returnconstantornewfn")})</script>
</div>
<div style="display:block;background:#b3d9ff" id="divforsecondparamofmiscbuiltinfn">
<b>Second Parameter (if applicable)</b><br>
<script>$(function(){appendVisibleElementClone("divforsecondparamofmiscbuiltinfn", "returnconstantornewfn")})</script>
</div>
</div>

</div><!-- end div divforcallingbuiltinfn -->


<div id="divtoshowforloopsequence">
Note: This function will not have any return value.<br>
	<div id="divforloopconditionfn" style="display:block;background:#ffff80;">
		<b>Function 1</b><br>
		<script>
		$(function()
		{
			appendVisibleElementClone("divforloopconditionfn", "newfndetails");
			var idofclonedele = replacements["fnreturntype"];
			//console.log("idofclonedele="+idofclonedele);
			var fnReturnTypeTextbox = $("#"+idofclonedele)[0];
			fnReturnTypeTextbox.value = $("#termForBoolean")[0].value;;
			fnReturnTypeTextbox.readOnly = true;
			fnReturnTypeTextbox.style.backgroundColor = "#eeeeee";
		});
		</script>
	</div>
	<div id="divforfntocallrepeatedly" style="display:block;background:#ffff00">
		<b>Function 2</b><br>
		<script>
		$(function(){appendVisibleElementClone("divforfntocallrepeatedly", "newfndetails")})
		</script>
	</div>
</div>


<div id="divtoshowforifsequence">
	<div id="divforconditionfn" style="display:block;background:#f2e6ff">
		<b>Function 1</b><br>
		<script>
		$(function()
		{
			appendVisibleElementClone("divforconditionfn", "newfndetails");
			var idofclonedele = replacements["fnreturntype"];
			//console.log("divforconditionfn: idofclonedele="+idofclonedele);
			var fnReturnTypeTextbox = $("#"+idofclonedele)[0];
			fnReturnTypeTextbox.value = $("#termForBoolean")[0].value;			
			//console.log("divforconditionfn: fnReturnTypeTextbox.value ='"+fnReturnTypeTextbox.value+"'");			
			fnReturnTypeTextbox.readOnly = true;
			fnReturnTypeTextbox.style.backgroundColor = "#eeeeee";
		});
		</script>
	</div>
	<div id="divforvaluetoreturnifcondfnreturnstrue" style="display:block;background:#e6ccff">
		<b>Value to return, in case function 1 returns 'true'</b><br>
		<script>
		$(function(){appendVisibleElementClone("divforvaluetoreturnifcondfnreturnstrue", "returnconstantornewfn")})
		</script>		
	</div>
</div>



<div id="divtoshowforfncallsequence">
	<div id="divforfirstfncallinthesequence" style="display:block;background:#99ccff">
		<b>First function called in the sequence</b><br>
		<script>
		$(function()
		{
			appendVisibleElementClone("divforfirstfncallinthesequence", "newfndetails");
			var idofclonedele = replacements["fnreturntype"];
			//console.log("idofclonedele="+idofclonedele);
			var fnReturnTypeTextbox = $("#"+idofclonedele)[0];
			fnReturnTypeTextbox.value = "(void or ignored)";
			fnReturnTypeTextbox.readOnly = true;
			fnReturnTypeTextbox.style.backgroundColor = "#eeeeee";
		});
		</script>
	</div>
	<div id="divforvaluetoreturn" style="display:block;background:#bbbbff;">
		<b>Overall return value of the sequence</b><br>
		<script>
		$(function(){
		//origAlert("Running component creation for overall result of the sequence")
		appendVisibleElementClone("divforvaluetoreturn", "returnconstantornewfn")})
		//origAlert("Ran component creation for overall result of the sequence")
		</script>
	</div>
</div>

</div><!--end of div needsSubFns -->

</div><!-- divtoshowforcreationofapprovedfn -->

</div><!-- divfortaskthatspecifiescreationofafunction -->


<div id="divfortaskthatdoesnotspecifycreationofafunction" style="background:#f0ddff;">
Is this task a 'requirement', or is it a 'simple use case'? <button type="button" 
onclick="alert($('#divForWhatIsASimpleUseCase')[0].innerText)">?</button> 
<select id="taskSplitTypeDropdown" class="wizardDropdown">
	<option>&nbsp;</option>
	<option value="needsSubRequirements">requirement</option>	
	<option value="needsUseCase">simple use case</option>	
</select><br><br>
<div id="divForWhatIsASimpleUseCase" style="display:none !important;">  
A 'simple use case' starts with an 'event' like a user clicking a button, application starting etc.<br>
Based on some condition, a function is run.<br>
Whereas, a 'requirement' can be broken down into sub-requirements and eventually, 'simple use cases'.
</div>

<div id="needsSubRequirements">
<div id="firstSubrequirementDiv" style="background:#f0ddf0">
First subtask<br> 
<script>
$(function(){appendVisibleElementClone("firstSubrequirementDiv","summAndDesc")})
</script>
</div>
<br><br>
<div id="secondSubrequirementDiv" style="display:block;background:#e0ddf0">
Second subtask<br>
<script>
$(function(){appendVisibleElementClone("secondSubrequirementDiv","summAndDesc")})
</script>
</div>
</div><!-- needsSubRequirements -->

<div id="needsUseCase">
<!--Object/UI element that raises the event (e.g. 'Application') (pseudo-code or imaginary names are ok!) <input type="text"><br>-->
<!-- Commenting out the name to keep it simple, the event name will indicate!-->
Description of event  (e.g. 'Application Start', 'Click on button X of screen Y')<br>
<input type="text"><br><br>
<div id="divforexecutionfn" style="display:block !important; background:#ddddee;">
<b>Function to run for this simple use case</b><br>
Note: It is ok if this task is not the only one that is triggered by this event.<br>
It is also ok if this task is run only under certain conditions.<br><br> 
<script>
$(function(){appendVisibleElementClone("divforexecutionfn","newfndetails")})
</script>
</div>
</div>

</div><!-- divfortaskthatdoesnotspecifycreationofafunction -->

<div style="display:none"><!-- outer hidden div for all reusable template divs-->

<div id="summAndDesc">
	Summary<button onclick="copyFromTaskSummary($('#subtasksummary')[0]);">Paste parent task's summary as starting point</button><br> 
	<input id="subtasksummary" type="text" size="120"><br>
	<br>
	Description<button onclick="copyFromTaskDesc($('#subtaskdesc')[0]);">Paste parent task's description as starting point</button><br>
	<textarea id="subtaskdesc" rows="5" cols="120"></textarea><br>
	<button onclick="showdiff($('#subtaskdesc')[0])">Compare 
	with parent task description</button><br>
</div><!-- end summAndDesc -->

<div id="returnconstantornewfn"> 
Does the value to be returned just need to be a constant? 
<select id="optiontoreturnconstantorcallfn" class="wizardDropdown">
<option >&nbsp;</option>
<option value="divToReturnConst">Yes</option>
<option value="divToReturnValueOfAFncall">No</option>
</select><br><br>

<div id="divToReturnConst">
<script>$(function(){appendVisibleElementClone("divToReturnConst", "returnConstant")})</script>
</div>

<div id="divToReturnValueOfAFncall" style="background:#9999ff;">
<script>$(function(){appendVisibleElementClone("divToReturnValueOfAFncall", "newfndetails")})</script>
</div>

</div><!-- end of div returnconstantornewfn -->

<div id="newfndetails"> 
Describe the function to be run:<br>
<input type=text size="30"><br><br> 
Type of data returned (String, Number, Map of keys and values etc.) <input type=text 
style="size:30 !important" id="fnreturntype"> <!--Description <input type=text size="90">--> <br> 
<!--File Name  </pre><input type=text size="30"><pre> --->
<!-- Let us have user defined functions as parameterless otherwise difficult to maintain binary work breakdown!
Parameter 1 <input type=text size="30"> Type <input type=text size="30"> Description <input type=text size="60"> <br> 
Parameter 2 <input type=text size="30"> Type <input type=text size="30"> Description <input type=text size="60"> <br> 
Parameter 3 <input type=text size="30"> Type <input type=text size="30"> Description <input type=text size="60"> <br>-->
<br> 
Description  <br>
<textarea rows="5" cols="120"></textarea><br>
<br>
Note the following:<br>
1. The function description must be enough to clearly and completely describe the task, without needing to refer to any other task.<br>
2. You do not have to write code inside the description of the above function. Just clearly describe what the function does.<br> 
The function will be broken into 2 parts by a crowd member as a part of another task. <br>
3. The SPOCs will decide whether you have described a new, existing or ready-made function. They will decide the actual line of code.<br><br>
</div>


<div id="returnConstant" style="background:#dddddd;">
Value of the constant <input><br><br>
Reason for choosing this value, and any other possible values it might change to<br>
<textarea id="reasonForChoosingConst" rows="5" cols="120"></textarea><br>
</div>

</div><!--END outer hidden div for all reusable template divs-->

<!-- TESTING: This comment should not show up in the text to reply with -->
<input type="hidden" value="boolean" id="termForBoolean">
</div><!-- divThatCreatesTheTextToReplyWith -->
<br>
<button id="btnToShowNextSteps" style="display:none !important;" 
onclick="showNextSteps();">Next...</button>
<div id="divForNextSteps" style="display:none">
<br>
<b id="nextStepsCaption">Next steps</b><br><br> 

1.  Reply to all, keeping the subject of the mail the same. Mail the text in the textarea below.<br> 
If you have edited the input fields after clicking the 'Next'button, ensure that you click the 'Next' button again:<br>
<textarea id="textToReplyWith" rows="10" cols="120" style="background:#eeffee;"></textarea><br><br>
<pre>
2. Next:
	a) The code reuse SPOC identified for this project, will review and integrate the pseudo-code that you created for this task.
	c) If you broke this task into subtasks that need to be further crowdsourced, a SPOC will create new tasks in the crowdsourcing vendor's task tracker. 
	This SPOC will then send emails to crowd members who have requested work, to break down these subtasks. 

You can now proceed to break down other tasks assigned to you. Make sure to reserve enough time for rework.

</pre><b style="color:red;">Important</b><pre> 
In case of closed-source development projects: 
Do not reveal the details of any task assigned to you or created by you to anyone, except of course to the designated crowd interaction SPOC of your project.
Violation of the above will lead to financial loss for yourself, the other crowd members, your customer and organization and may be a punishable legal offence.

Note however, that you are free to share information about the </pre><b>number</b><pre> of tasks you broke down, with your fellow crowd members.
			   
In case of any mistakes, you have to correct the summary and description of the tasks you created.
In case you do not complete the assigned task in time or made mistakes, a penalty will apply.

</pre>
</div>
<script>
$(function()
{
 disablePage("Initializing...")
 setTimeout(init,0)
}
)

function init()
{
 $(":button" ).prop("type", "button"); //At startup, ensure that all buttons are of type 'button'.
 $("textarea").prop("maxlength","2000");
 $("#textToReplyWith").prop("maxlength","10000");
 $(':text').prop("maxlength", "150");
 setupDisplayOfNumOfCharsTypedAndCharLimit(); 
 //origAlert("Running markAsWizardDropdowns")
 markAsWizardDropdowns($(".wizardDropdown")
 /*[
 "isThisAFnDropdown",
 "isPermissionToCrowdsourceGivenDropdown",
 "fnSplitTypeDropdown",
 "taskSplitTypeDropdown",
 "codeblockdropdown",
 "builtindropdown",
 "optiontoreturnconstantorcallfn"
 ]*/);
 //origAlert("Ran markAsWizardDropdowns")
 handleImFamiliarUnchecked()
 enablePage("Initializing...")
}
</script>
</body>
</html>
