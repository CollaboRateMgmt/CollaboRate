<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>
		CollaboRate v1.0 - Micro-Work Binary Breakdown Structure (MWBBS) Tool for Crowdsourced IT
	</title>
	<style>
		* {font-family: Sans-Serif;}
		pre 
		{
			display:inline;
			white-space: pre-wrap;       /* css-3 */
			white-space: -moz-pre-wrap;  /* Mozilla, since 1999 */
			white-space: -pre-wrap;      /* Opera 4-6 */
			white-space: -o-pre-wrap;    /* Opera 7 */
			word-wrap: break-word;       /* Internet Explorer 5.5+ */
		}

		div
		{
			display:none;/*hide divs by default*/
			padding-left: 5px;/*so that nested divs can be visualized*/
		}
	</style>
	<!--
	<script
		src="https://code.jquery.com/jquery-3.1.1.slim.min.js"
		integrity="sha256-/SIrNqv8h6QGKDuNoLGA4iret+kyesCkHGzVUUV0shc="
		crossorigin="anonymous">
	</script>
	--->
	<script src="jquery-3.1.1.slim.min.js"></script>
	
	<script>
//BEGIN src="https://raw.githubusercontent.com/spencertipping/jquery.fix.clone/master/jquery.fix.clone.js">
		// Textarea and select clone() bug workaround | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Motivation.
// jQuery's clone() method works in most cases, but it fails to copy the value of textareas and select elements. This patch replaces jQuery's clone() method with a wrapper that fills in the
// values after the fact.

// An interesting error case submitted by Piotr Przybyl: If two <select> options had the same value, the clone() method would select the wrong one in the cloned box. The fix, suggested by Piotr
// and implemented here, is to use the selectedIndex property on the <select> box itself rather than relying on jQuery's value-based val().

(function (original) {
  jQuery.fn.clone = function () {
    var result           = original.apply(this, arguments),
        my_textareas     = this.find('textarea').add(this.filter('textarea')),
        result_textareas = result.find('textarea').add(result.filter('textarea')),
        my_selects       = this.find('select').add(this.filter('select')),
        result_selects   = result.find('select').add(result.filter('select'));

    for (var i = 0, l = my_textareas.length; i < l; ++i) $(result_textareas[i]).val($(my_textareas[i]).val());
    for (var i = 0, l = my_selects.length;   i < l; ++i) {
      for (var j = 0, m = my_selects[i].options.length; j < m; ++j) {
        if (my_selects[i].options[j].selected === true) {
          result_selects[i].options[j].selected = true;
        }
      }
    }
    return result;
  };
}) (jQuery.fn.clone);

// Generated by SDoc 
//END src="https://raw.githubusercontent.com/spencertipping/jquery.fix.clone/master/jquery.fix.clone.js">

//shortcut for document.getElementById or for ($("#"+eleid)[0]))
function el(eleid){return document.getElementById(eleid)}

//Shows the div for the currently selected option
function showDivForCurrentlySelectedOption(drpdn, optionDivsClass)
{
	var dbg = false;
	if(dbg)
	{
		console.log("showDivForCurrentlySelectedOption(): drpdn="+drpdn.outerHTML);
		console.log("showDivForCurrentlySelectedOption(): drpdn="+drpdn.outerHTML);
		console.log("showDivForCurrentlySelectedOption(): optionDivsClass='"+optionDivsClass+"'");
		console.log("showDivForCurrentlySelectedOption(): drpdn.value (id of div to make visible) = '"+drpdn.value+"'");
	}
	$("."+optionDivsClass).hide();
	if(drpdn.value != ""){$("#"+drpdn.value).show();}
	if(dbg)
	{
		console.log("showDivForCurrentlySelectedOption(): now check whether the element with id '"+drpdn.value+"' has been made visible.");
		console.log("showDivForCurrentlySelectedOption(): number of elements with id '"+drpdn.value+"' are "+$("#"+drpdn.value).length);
	}
}

function optionChanged_howBigSpecific(drpdn, optionDivsClass)
{
	showDivForCurrentlySelectedOption(drpdn, optionDivsClass);
	if(drpdn.value != ""){$("#btnToshowNextSteps").show();}
}

var eleIdsDifferentiator = 0;
var replacements;

String.prototype.replaceAll = function(search, replacement) {
    var target = this;
    return target.replace(new RegExp(search, 'g'), replacement);
};

var dbgWithIdsMadeDifferent = false;

//returns a string of the outerHTML of the specified eleId but all all ids and reference to those ids made different.
function withIdsMadeDifferent(eleId)
{
	if(dbgWithIdsMadeDifferent)
	{
		console.log("withIdsMadeDifferent(): On entry, eleId='"+eleId+"', ($(\"#\"+eleId)[0]).outerHTML='"+($("#"+eleId)[0]).outerHTML+"'...");
	}
	var s = withIdsMadeDifferentButNotReferencesToThem(($("#"+eleId).clone(true,true))[0]).outerHTML;
	if(dbgWithIdsMadeDifferent)
	{
		console.log("withIdsMadeDifferent(): After withIdsMadeDifferentButNotReferencesToThem(), eleId='"+eleId+"', s='"+s+"'...");
	}
	for (var key in replacements)
	{
		if(dbgWithIdsMadeDifferent)
		{
			console.log("withIdsMadeDifferent(): string to replace = '"+key+"', replacement = '"+replacements[key]+"'");
		}
		s = s.replaceAll(key,replacements[key]);
		if(dbgWithIdsMadeDifferent)
		{
			console.log("withIdsMadeDifferent(): Now s='"+s+"'...");
		}
	}
	if(dbgWithIdsMadeDifferent)
	{
		console.log("withIdsMadeDifferent(): On exit, s='"+s+"'...");
	}
	return s;
}

function withIdsMadeDifferentButNotReferencesToThem(ele)
{	
	withIdsMadeDifferentButNotReferencesToThemInit()
	withIdsMadeDifferentButNotReferencesToThemLoop(ele);
	return ele;
}

function withIdsMadeDifferentButNotReferencesToThemInit()
{
	eleIdsDifferentiator++
	replacements = {}
}

function withIdsMadeDifferentButNotReferencesToThemLoop(ele)
{
	if(ele.id != null && ele.id != "")
	{
		var oldEleId = ele.id;
		
		//this will prevent double-replacement of the oldEleId:
		ele.id = ele.id.substring(0,1) +eleIdsDifferentiator + ele.id.substring(1);
		
		replacements[oldEleId] = ele.id;
	}	
	var cn = ele.childNodes;
	for(var i=0;i<cn.length;i++)
	{
		withIdsMadeDifferentButNotReferencesToThemLoop(cn[i]);
	}	
}

function copyFromTaskSummary(destinationTextbox)
{	
	destinationTextbox.value = ($("#taskSummary")[0]).value + destinationTextbox.value;
}

function copyFromTaskDesc(destinationTextbox)
{		
	//console.log("destinationTextbox.outerHTML="+destinationTextbox.outerHTML)
	destinationTextbox.value = ($("#taskDesc")[0]).value + destinationTextbox.value;
}

function getTextOfNode(n)
{
	//console.log("gettextofnode: entry");
	if(!($(n).is(':visible'))){return ""}
	if(n.tagName=="BUTTON"){return ""}
	if(n.tagName=="SELECT")
	{
		//console.log(n.outerHTML)
		var r = n.options[n.selectedIndex].text
		//console.log("For select, returning '"+r+"'...")
		return r
	}
	if(n.childNodes.length==0)
	{
		if(n.text!=undefined){return n.text;}
		if(n.value!=undefined){return n.value;}
	}
	var t = "";
	//console.log("Getting ")
	$(n.childNodes).each(function()
	{
		//console.log("this="+this.outerHTML);
		t+= getTextOfNode(this);
	});
	//console.log("n.outerText='"+n.outerText+"', n='"+n.outerHTML+"', n.innerText='"+n.innerText+"'");
	return t;
}

function showNextSteps_old()
{
	//console.log("here");
	($("#textForIssueTrackerComment")[0]).value = $('#contentToPasteAsIssueTrackerComment').children(":visible").text();//getTextOfNode($('#contentToPasteAsIssueTrackerComment')[0]);
	//console.log("done!")
	$("#divForNextSteps").show();	
	window.scrollTo(0,$('#nextStepsCaption').offset().top);	
}

var dbg_getTextToPaste_uniquectr 

function getTextToPaste()
{
	var ele = $('#contentToPasteAsIssueTrackerComment')[0];
	dbg_getTextToPaste_uniquectr = 0
	return getTextToPasteFrom(ele,0)
}

function getTextToPasteFrom(ele,indentationLevel)
{
	var dbg = false	
	if(dbg)
	{
		dbg_getTextToPaste_uniquectr++
		var dbgmyid = dbg_getTextToPaste_uniquectr
	}
	//console.log("ele.outerHTML = "+ele.outerHTML)
	//console.log("ele.innerText = "+ele.innerText)
	//console.log("ele.textContent = "+ele.textContent)
	//return ele.innerText
	//if(!($(ele).is(':visible'))){return ""}
	if(ele.tagName=="DIV" && getComputedStyle(ele).getPropertyValue("display") == "none"){return ""}
	if(ele.tagName=="SCRIPT"){return ""}
	if(ele.tagName=="BUTTON"){return ""}
	if(ele.tagName=="BR"){return "\n"}
	if((ele.tagName == "INPUT" && ele.type == "text") || (ele.tagName == "TEXTAREA"))
	{
		return ele.value
	}
	if(ele.tagName=="SELECT")
	{
		return ele.options[ele.selectedIndex].text
	}
	var s = ""	
	if(ele.nodeType == 3)
	{		
		var r = ele.nodeValue.trim()//trims whitespaces and not just spaces!
		if(r != ele.nodeValue){return r + " "}
		return r
	}
	var indent, ctr, dbgmyid;
	if(dbg)
	{
		ctr=0
		indent = "    ".repeat(indentationLevel)
		s+=indent+"START dbgmyid="+dbgmyid+", tagName="+ele.tagName+",nodeType="+ele.nodeType+"\n"
	}
	$(ele).contents().each(function(){
		if(dbg)
		{			
			s+=indent+"dbgmyid="+dbgmyid+", ele at idx "+ctr+":\n"
			s+=getTextToPasteFrom(this,indentationLevel+1)
			s+="\n"+indent+"dbgmyid="+dbgmyid+", end ele at idx "+ctr+"\n";
			ctr++
		}
		else
		{
			s+=getTextToPasteFrom(this,indentationLevel+1);
		}
	});
	if(dbg)
	{
		s+=indent+"END dbgmyid="+dbgmyid+", tagName="+ele.tagName+",nodeType="+ele.nodeType+"\n"
	}
	return s;
}



function showNextSteps()
{
	($("#textForIssueTrackerComment")[0]).value = getTextToPaste()
	$("#divForNextSteps").show();	
	window.scrollTo(0,$('#nextStepsCaption').offset().top);	
}

function showNextSteps_old2()
{
	var nodeToClone = $('#contentToPasteAsIssueTrackerComment')[0];
	
	var clonedNode = $(nodeToClone).clone(true);
	
	var m = {};
	document.body.appendChild(clonedNode[0]);
	//cloneNode[0].style.backgroundColor = "red";
	//cloneNode[0].style.paddingLeft = "50px";
		
	$(clonedNode).find(":input").each(function()//unfortunately all selects are considered as not visible.. so have to 
												//cycle through both visible and invisible inputs
	{
		var inputEle = this;			
		if(inputEle.tagName=="SELECT" )
		{	
			//console.log("Ok, now handling "+inputEle.outerHTML);
			if(!($(inputEle).is(":hidden")))
			{
				//console.log("This dropdown is not hidden, so getting its text...");					
				//console.log("selectedIndex="+inputEle.selectedIndex+", total number of options = "+inputEle.options.length); 
				var txt  = "<pre>"+inputEle.options[inputEle.selectedIndex].text+"</pre>";
				//console.log("The text for this dropdown will be '"+txt+"'");
				$(inputEle).after(txt);
			}				
			else
			{
				//console.log("This dropdown is hidden, so skipping it...");
			}
		}
		else if
		(
			(inputEle.tagName == "INPUT" && inputEle.type == "text")
			||
			(inputEle.tagName == "TEXTAREA")
		)
		{				
			//console.log("Found text '"+inputEle.value+"' in textbox or textarea...")
			$(inputEle).after("<pre>"+inputEle.value+"</pre>");
		}
	});

	//we are not interested in buttons text!
	$(clonedNode).find("button").each(function(){this.innerHTML = "";});
	
	//for some strange reason, scripts are considered as visible by jquery!
	$(clonedNode).find("script").each(function(){this.innerHTML = "";});
	
	//for some strange reason, all select options are considered as visible by jquery!
	$(clonedNode).find("select").each(function(){this.innerHTML = "";});
	
	var t = $(clonedNode).children(":visible");
	t = t.filter(function() 
	{
		var element = $(this);
		if(element.is(":hidden")) 
		{
			element.remove();
			return false;
		}
		return true;
	});
	t = t.text();	
	$(clonedNode).remove();
	//t = nodeToClone.textContent;//gets the visible and invisible text content
	($("#textForIssueTrackerComment")[0]).value = t;
	$("#divForNextSteps").show();
	window.scrollTo(0,document.body.scrollHeight);
}

function isValidEleId(id)
{
	return (document.getElementById(id ) != null)
}

function assert(b)
{
	if(!b){throw new Error("Assertion failed");}
}

var gldbg = false;

function appendVisibleElementClone(parentEleId,childEleId)
{
	assert(isValidEleId(parentEleId))
	assert(isValidEleId(childEleId))
	var wasVisible = $("#"+childEleId).is(":visible");
	if(!wasVisible)
	{
		$("#"+childEleId).show();
	}
	var cch = withIdsMadeDifferent(childEleId)
	if(gldbg){console.log(cch)}
	$("#"+parentEleId).append(cch);	
	if(!wasVisible)
	{
		$("#"+childEleId).hide();
	}
}
	</script>
</head>
<body>
<H2 id="pageheading">
	<script>
		$(function(){$("#pageheading").append(document.title);});
	</script>
</H2>
<div style="text-align:center;display:block !important;"><small>Mostly tested with Mozilla FireFox</small></div>
<a href=# onclick="window.open('https://github.com/sohrabsaran/CollaboRate');return false");">Help</a><br>
<br>
This tool will guide you to break down the task assigned to you in the issue tracking system.<br>
<br>
<b>Task Summary (paste the task's summary into the textbox below) </b><pre><!--(the phrase 'create function' in summary could be taken as a keyword for some workflow/validations)--> 
</pre><input id="taskSummary" size="120" type=text><!--style="background:#eeeeee"--><pre> 

</PRE><b>Task Description (paste the task's description into the textarea below) </b><pre> 
</pre><textarea rows="5" cols="120" id="taskDesc">
</textarea><!--style="background:#eeeeee;"--><br>
Note: the task description must be enough to clearly and completely describe the task, without needing to refer to any other task or diagram.<br> 
Otherwise, bring this to the notice of the task creator, preferably via a comment against that task.<br>
<br>
<b style="color:red">Note that you do not need to fully solve this task!</b> <button type="button" 
onclick="alert(($('#divForExplanationForWhyYouDoNotNeedToFullySolveThisTask')[0]).innerText)">?</button>
<br>
<div id="divForExplanationForWhyYouDoNotNeedToFullySolveThisTask">
Your microtask is just to break down this task into 2 subtasks.<br> 
Exception: the task to solve is to create a function, and it is found that the function just needs to call a readymade function with constant values as parameters.<br>
Other crowd members if available, will preferably break down these 2 subtasks (and so on).<br> 
Additionally, once your breakdown is reviewed, you will need to create the 2 subtasks in the issue tracker, and then act as the reviewer for the break down of these subtasks.<br>
Instead of fully solving this task, you can break down other tasks assigned to you.
</div>
<br>
<!--
<b>Task Created by </b> <input id="createdBy" size="60" type=text style="background:#eeeeee" value="(Crowd Member Email ID got from issue tracker)"><pre>(this person will act as reviewer for your microtask) 

</pre>
-->

<!--Though it is hoped that this tool will be used by non-programmers as well, basic understanding of programming concepts is useful.<br>-->

<div id="contentToPasteAsIssueTrackerComment" style="display:block;background:#eeeeff;">
<b>Does this task specify the creation of a function (a sequence of steps)?</b> <select 
	id="isThisAFnDropdown" onchange="showDivForCurrentlySelectedOption(this, 'classfordivfordoesthistaskspecifyfnoption');">
<option>&nbsp;</option>
<option value="divfortaskthatspecifiescreationofafunction">Yes</option>
<option value="divfortaskthatdoesnotspecifycreationofafunction">No</option>
</select><br><br>

<div id="divfortaskthatspecifiescreationofafunction" class="classfordivfordoesthistaskspecifyfnoption" 
style="background:#ffe066">
(Question applicable for projects where task visibility is unrestricted e.g. experimental or open-source projects, answer 'yes' if not applicable):<br>
<b> Has go-ahead for creation of this function been given in the form of comments in the issue tracker, by BOTH programming language/third-party code-reuse SPOC, and also by the code reuse SPOC?</b><select 
onchange = "showDivForCurrentlySelectedOption(this,'classfordivforhasfngoaheadbeengiven')"
<!--onchange2="if(this.value=='no'){console.log('You need to get approval before breaking down this task.');}else{;$('#divtoshowforcreationofapprovedfn').show();}"-->
>
<option>&nbsp;</option>
<option value="divtoshowforcreationofapprovedfn">Yes</option>
<option value="needtogetapprovalmsgdiv">No</option>
</select><br><br>

<div id="needtogetapprovalmsgdiv" class="classfordivforhasfngoaheadbeengiven">
You need to get approval before breaking down this task.
</div>

<div id="divtoshowforcreationofapprovedfn" class="classfordivforhasfngoaheadbeengiven" style="background:#eeeeff" >
<b>What is the best way to break down this function?</b>  
<select id="taskSplitTypeDropdown" onchange="optionChanged_howBigSpecific(this,'bigtaskoption');">
	<option>&nbsp;</option>	
	<option value="nonObviousReqAndElaboratedNewFn">Break it down into a non-obvious requirement/usecase, and a new task for this new function but with more details.</option>
	<option value="needsSubFns">Calls 1-2 other functions.</option>
	<option value="unnecessaryJustNeedsToReturnConstant">This task is unnecessary. This function just needs to return a constant!</option>
</select><br><br>

<div class="bigtaskoption" id="unnecessaryJustNeedsToReturnConstant">
<script>
$(function(){appendVisibleElementClone("unnecessaryJustNeedsToReturnConstant", "returnConstant")})
</script>
</div>

<div class="bigtaskoption" id="nonObviousReqAndElaboratedNewFn">
<div style="display:block !important;background:#ffeeee;" id="nonObviousReqOrUseCase">
<b>Enter the details for the non-obvious requirement/use case</b><br><br>
<script>
$(function(){appendVisibleElementClone("nonObviousReqOrUseCase", "summAndDesc")})
</script>
</div><!-- nonObviousReqOrUseCase -->
<pre> 

Enter the more detailed technical description for this new function to be created
</pre>
<script>
$(function(){appendVisibleElementClone("nonObviousReqAndElaboratedNewFn","newfndetails")})
</script>
</div><!-- end div nonObviousReqAndElaboratedNewFn-->

<div class="bigtaskoption" id="needsSubFns" style="background:#b3ffff">
Basic code block that joins the 1-2 new functions:
<select id="codeblockdropdown" onchange="showDivForCurrentlySelectedOption(this, 'classforcodeblockdiv')">
<option>&nbsp;</option>
<option value="divtoshowforfncallsequence">sequence - function1();return something; - Call function1. Then return something.</option>
<option value="divtoshowforifsequence">if(function1()){return something}else{return false} - If function1 returns 'true' then return something, else return 'false'</option>
<option value="divtoshowforloopsequence">while(function1()){function2()} - While function1 returns 'true', keep calling function2</option>
<option value="divforcallingreadymadefn">return readymadefunction(something1,something2)</value>
</select><br><br>

<div id="divforcallingreadymadefn" class="classforcodeblockdiv">
Select the readymade function to call <select 
id="readymadedropdown" onchange="showDivForCurrentlySelectedOption(this, 'classforreadymadefncalldiv')">
<option>&nbsp;</option>

<option value="divtogetuserinputfromscreen">Get user input from the screen as a string</option>
<!-- 
params:
1. Something that returns the unique name of the screen of the input field
2. Something that returns the unique name of the input field on the screen
-->

<option value="divtogetattrofobjorelofarr">Get attribute of object or element of array</option>
<!-- 
params:
1. something that returns object/array name
2. something that returns attribute name/value of 0-based index
-->

<option value="divtogetsomethingpreviouslymemorized">Get something that was quickly memorized</option>
<!-- params: 
	1. something that returns the variable name.
-->

<option value="divtogetsomethingpreviouslymemorizedforsession">Get something that was memorized for the web browser session</option>
<!-- params: 
	1. something that returns the variable name.
-->

<option value="divtoshowforreadfromdb">Read object(s) from database</option>
<!-- params: 
1. something that returns the table name, (always fetches columns of this table and not of joined table, we will have unique names and mysql enums rather than id,pk,fk etc.)
2. sql select 'where' clause function (filter function) whose return type is boolean - if false then object to check gets filtered out. 
The object to check is already stored in memory with name 'objectToFilter'
So parameters are limited to <=2 for binary WBS
-->

<option value="divtoquicklymemorizesomething">Quickly memorize something for later reference in this simple use case</option>
<!-- store value in a per-thread global variable.  
params (limited to <=2 for binary WBS): 
1  name: something that returns the name by which to memorize the data
2. value: something that returns the object or value to be memorized
-->

<option value="divtomemorizesomethingforthesession">Memorize something for the browser session</option>
<!-- store value in a session variable.  
params (limited to <=2 for binary WBS): 
1  name: something that returns the name by which to memorize the data
2. value: something that returns the object or value to be memorized
-->

<option value="divtoinsnewobjindb">Insert new object in the database and return the unique id generated</option>
<!-- 
params:
1. something that returns the object to insert 
2. something that returns the name of the table in which to insert the object
Returns: id of inserted row 
-->

<option value="divforupdatedb">Update existing objects in the database</option>
<!-- 
params:
1. function to read objects from the database
2. function to modify an object. The object is passed to the function via a memory variable named 'objectToUpdate'
-->

<option value="divtoupdatepropofpartofscreen">Update property of a part of the screen</option>
<!--
params:
1. something to give the name of the part of the screen to update (in format <screen name>_<field name>_<property name>
2. something to give the new value to assign to the property
-->

<option value="divformiscreadymadefn">Any other miscellaneous readymade function that should exist, having not more than 2 inputs</option>
<!--
params:
1. Something1
2. Something2
-->

</select><br><br>

<div id="divtogetuserinputfromscreen" class="classforreadymadefncalldiv">
<!-- 
Get user input from the screen as a string
params:
1. Something that returns the unique name of the screen of the input field.
2. Something that returns the unique name of the input field on the screen.
-->
<div style="display:block;background:#cce6ff" id="divforscreenname">
<b>Unique name of the screen of the input field</b><br>
<script>$(function(){appendVisibleElementClone("divforscreenname", "returnconstantornewfn")})</script>
</div>
<div style="display:block;background:#b3d9ff" id="divforfieldnameonitsscreen">
<b>Unique name of the input field on its screen</b><br>
<script>$(function(){appendVisibleElementClone("divforfieldnameonitsscreen", "returnconstantornewfn")})</script>
</div>
</div>

<div id="divtogetattrofobjorelofarr" class="classforreadymadefncalldiv">
<!-- 
Get attribute of object or element of array
params:
1. something that returns object/array
2. something that returns attribute name/value of 0-based index
-->
<div style="display:block;background:#cce6ff" id="divforobjorarr">
<b>Object or array</b><br>
<script>$(function(){appendVisibleElementClone("divforobjorarr", "newfndetails")})</script>
</div>
<div style="display:block;background:#b3d9ff" id="divforattrname">
<b>Attribute name of object, or value of the 0-based index</b><br>
<script>$(function(){appendVisibleElementClone("divforattrname", "returnconstantornewfn")})</script>
</div>
</div>

<div id="divtogetsomethingpreviouslymemorized"  class="classforreadymadefncalldiv">
<!-- params: 
	1. something that returns the variable name.
-->
<b>Memory Variable name</b><br>
<script>$(function(){appendVisibleElementClone("divtogetsomethingpreviouslymemorized", "returnconstantornewfn")})</script>
</div>

<div id="divtogetsomethingpreviouslymemorizedforsession" class="classforreadymadefncalldiv">
<!-- params: 
	1. something that returns the variable name.
-->
<b>Session Variable name</b><br>
<script>$(function(){appendVisibleElementClone("divtogetsomethingpreviouslymemorizedforsession", "returnconstantornewfn")})</script>
</div>

<div id="divtoshowforreadfromdb" class="classforreadymadefncalldiv">
<!-- 
Read object(s) from database
params: 
1. something that returns the table name, (always fetches columns of this table and not of joined table, we will have unique names and mysql enums rather than id,pk,fk etc.)
2. sql select 'where' clause function (filter function) whose return type is boolean - if false then object to check gets filtered out. 
The object to check is already stored in memory with name 'objectToFilter'
So parameters are limited to <=2 for binary WBS
-->
<div style="display:block;background:#cce6ff" id="divfortablename">
<b>Table Name</b><br>
<script>$(function(){appendVisibleElementClone("divfortablename", "returnconstantornewfn")})</script>
</div>
<div style="display:block;background:#b3d9ff" id="divforfilterfn">
<b>Filter function whose return type is 'true' or 'false' - if false, then the object to check gets filtered out.</b><br>
Note: The object to check will already stored in memory by the readymade function, with name 'objectToFilter'<br>
<script>$(function(){appendVisibleElementClone("divforfilterfn", "newfndetails")})</script>
</div>
</div>

<div id="divtoquicklymemorizesomething" class="classforreadymadefncalldiv">
<!-- store value in a per-thread global variable.  
params (limited to <=2 for binary WBS): 
1  name: something that returns the name by which to memorize the data
2. value: something that returns the object or value to be memorized
-->
<div style="display:block;background:#cce6ff" id="divformemvarnametowriteto">
<b>Unique name of the memory location (variable)</b><br>
<script>$(function(){appendVisibleElementClone("divformemvarnametowriteto", "returnconstantornewfn")})</script>
</div>
<div style="display:block;background:#b3d9ff" id="divfordatatomemorizeinmemvar">
<b>Data to memorize</b><br>
<script>$(function(){appendVisibleElementClone("divfordatatomemorizeinmemvar", "returnconstantornewfn")})</script>
</div>
</div>

<div id="divtomemorizesomethingforthesession" class="classforreadymadefncalldiv">
<!-- store value in a per-thread global variable.  
params (limited to <=2 for binary WBS): 
1  name: something that returns the name by which to memorize the data
2. value: something that returns the object or value to be memorized
-->
<div style="display:block;background:#cce6ff" id="divformemsessionvarnametowriteto">
<b>Unique name of the session memory location (variable)</b><br>
<script>$(function(){appendVisibleElementClone("divformemsessionvarnametowriteto", "returnconstantornewfn")})</script>
</div>
<div style="display:block;background:#b3d9ff" id="divfordatatomemorizeinsessionmemvar">
<b>Data to memorize</b><br>
<script>$(function(){appendVisibleElementClone("divfordatatomemorizeinsessionmemvar", "returnconstantornewfn")})</script>
</div>
</div>

<div id="divtoinsnewobjindb" class="classforreadymadefncalldiv">
<!-- 
Insert new object in the database and return the unique id generated
params:
1. something that returns the object to insert 
2. something that returns the name of the table in which to insert the object
Returns: id of inserted row 
-->
<div style="display:block;background:#cce6ff" id="divforobjtoins">
<b>Object to insert</b><br>
<script>$(function(){appendVisibleElementClone("divforobjtoins", "returnconstantornewfn")})</script>
</div>
<div style="display:block;background:#b3d9ff" id="divfornameoftabletoinsinto">
<b>Name of table to insert the object into</b><br>
<script>$(function(){appendVisibleElementClone("divfornameoftabletoinsinto", "returnconstantornewfn")})</script>
</div>
</div>

<div id="divforupdatedb" class="classforreadymadefncalldiv">
<!-- 
Update existing objects in the database
params:
1. function to read objects from the database
2. function to modify an object. The object is passed to the function via a memory variable named 'objectToUpdate'
-->
<div style="display:block;background:#cce6ff" id="divforfntoreadobjstoupdate">
<b>Function to read objects from the database</b><br>
<script>$(function(){appendVisibleElementClone("divforfntoreadobjstoupdate", "newfndetails")})</script>
</div>
<div style="display:block;background:#b3d9ff" id="divforfntoupdatedbobj">
<b>function to modify an object. The object is passed to the function via a memory variable named 'objectToUpdate'</b><br>
<script>$(function(){appendVisibleElementClone("divforfntoupdatedbobj", "newfndetails")})</script>
</div>
</div>

<div id="divtoupdatepropofpartofscreen" class="classforreadymadefncalldiv">
<!--
Update property of a part of the screen
params:
1. something to give the name of the part of the screen to update (in format <screen name>_<field name>_<property name>)
2. something to give the new value to assign to the property
-->
<div style="display:block;background:#cce6ff" id="divfornameofpartofscreentoupdate">
<b>Name of the part of the screen to update (in format &lt;screen name&gt;_&lt;field name&gt;_&lt;property name&gt;)</b><br>
<script>$(function(){appendVisibleElementClone("divfornameofpartofscreentoupdate", "returnconstantornewfn")})</script>
</div>
<div style="display:block;background:#b3d9ff" id="divforvaluetogivetoscreenpart">
<b>Value to assign to the property of the screen part</b><br>
<script>$(function(){appendVisibleElementClone("divforvaluetogivetoscreenpart", "returnconstantornewfn")})</script>
</div>
</div>

<div id="divformiscreadymadefn">
<!--
Any other miscellaneous readymade function that should exist, having not more than 2 inputs
params:
1. Something1
2. Something2
-->
<div style="display:block;background:#ffb3d9" id="divforfnnameanddescofmiscreadymadefn">
<script>$(function(){appendVisibleElementClone("divforfnnameanddescofmiscreadymadefn", "newfndetails")})</script>
</div>
<div style="display:block;background:#cce6ff" id="divforfirstparamofmiscreadymadefn">
<b>First Parameter</b><br>
<script>$(function(){appendVisibleElementClone("divforfirstparamofmiscreadymadefn", "returnconstantornewfn")})</script>
</div>
<div style="display:block;background:#b3d9ff" id="divforsecondparamofmiscreadymadefn">
<b>Second Parameter (if applicable)</b><br>
<script>$(function(){appendVisibleElementClone("divforsecondparamofmiscreadymadefn", "returnconstantornewfn")})</script>
</div>
</div>

</div><!-- end div divforcallingreadymadefn -->


<div id="divtoshowforloopsequence" class="classforcodeblockdiv">
	<div id="divforloopconditionfn" style="display:block;background:#ffff80;">
		<b>Loop Condition Function</b><br>
		<script>
		$(function()
		{
			appendVisibleElementClone("divforloopconditionfn", "newfndetails");
			var idofclonedele = replacements["fnreturntype"];
			//console.log("idofclonedele="+idofclonedele);
			var fnReturnTypeTextbox = $("#"+idofclonedele)[0];
			fnReturnTypeTextbox.value = "boolean (returns 'true' or 'false')";
			fnReturnTypeTextbox.readOnly = true;
			fnReturnTypeTextbox.style.backgroundColor = "#eeeeee";
		});
		</script>
	</div>
	<div id="divforfntocallrepeatedly" style="display:block;background:#ffff00">
		<b>Function to call in the loop</b><br>
		<script>
		$(function(){appendVisibleElementClone("divforfntocallrepeatedly", "newfndetails")})
		</script>
	</div>
</div>


<div id="divtoshowforifsequence" class="classforcodeblockdiv" >
	<div id="divforconditionfn" style="display:block;background:#f2e6ff">
		<b>Condition Function</b><br>
		<script>
		$(function()
		{
			appendVisibleElementClone("divforconditionfn", "newfndetails");
			var idofclonedele = replacements["fnreturntype"];
			//console.log("idofclonedele="+idofclonedele);
			var fnReturnTypeTextbox = $("#"+idofclonedele)[0];
			fnReturnTypeTextbox.value = "boolean (returns 'true' or 'false')";
			fnReturnTypeTextbox.readOnly = true;
			fnReturnTypeTextbox.style.backgroundColor = "#eeeeee";
		});
		</script>
	</div>
	<div id="divforvaluetoreturnifcondfnreturnstrue" style="display:block;background:#e6ccff">
		<b>Function to call and whose value will be returned, in case the condition function returns 'true'</b><br>
		<script>
		$(function(){appendVisibleElementClone("divforvaluetoreturnifcondfnreturnstrue", "newfndetails")})
		</script>		
	</div>
</div>



<div id="divtoshowforfncallsequence" class="classforcodeblockdiv">
	<div id="divforfirstfncallinthesequence" style="display:block;background:#99ccff">
		<b>First function called in the sequence</b><br>
		<script>
		$(function()
		{
			appendVisibleElementClone("divforfirstfncallinthesequence", "newfndetails");
			var idofclonedele = replacements["fnreturntype"];
			//console.log("idofclonedele="+idofclonedele);
			var fnReturnTypeTextbox = $("#"+idofclonedele)[0];
			fnReturnTypeTextbox.value = "(void or ignored)";
			fnReturnTypeTextbox.readOnly = true;
			fnReturnTypeTextbox.style.backgroundColor = "#eeeeee";
		});
		</script>
	</div>
	<div id="divforvaluetoreturn" style="display:block;background:#bbbbff;">
		<b>Overall result of the sequence</b><br>
		<script>
		$(function(){appendVisibleElementClone("divforvaluetoreturn", "returnconstantornewfn")})
		</script>
	</div>
</div>

<div id="divtoshowforreadfromdb" class="classforcodeblockdiv">
<b>Read from db</b><br>
Function that provides Table name (TODO)<br>
Function that provides Column name (TODO)<br>
Function that provides row id (TODO)<br>
</div>

</div><!--end of div needsSubFns -->

</div><!-- divtoshowforcreationofapprovedfn -->

</div><!-- divfortaskthatspecifiescreationofafunction -->


<div id="divfortaskthatdoesnotspecifycreationofafunction" class="classfordivfordoesthistaskspecifyfnoption" 
style="background:#f0ddff">
Is this task a requirement, or is it a 'simple use case'? <button type="button" 
onclick="alert($('#divForWhatIsASimpleUseCase')[0].innerText)">?</button> 
<select id="taskSplitTypeDropdown" onchange="optionChanged_howBigSpecific(this,'bigtaskoption');">
	<option>&nbsp;</option>
	<option value="needsSubRequirements">requirement</option>	
	<option value="needsUseCase">simple use case</option>	
</select><br><br>
<div id="divForWhatIsASimpleUseCase">  
A 'simple use case' starts with an 'event' like a user clicking a button, application starting etc.<br>
Based on some condition, a sequence of steps are performed.<br>
Whereas, a 'requirement' can be broken down into sub-requirements and eventually, 'simple use cases'.
</div>

<div class="bigtaskoption" id="needsSubRequirements">
<div id="firstSubrequirementDiv" style="display:block;background:#f0ddf0">
First sub-requirement/use case<br> 
<script>
$(function(){appendVisibleElementClone("firstSubrequirementDiv","summAndDesc")})
</script>
</div>
<br><br>
<div id="secondSubrequirementDiv" style="display:block;background:#e0ddf0">
Second sub-requirement/use case<br>
<script>
$(function(){appendVisibleElementClone("secondSubrequirementDiv","summAndDesc")})
</script>
</div>
</div><!-- needsSubRequirements -->

<div class="bigtaskoption" id="needsUseCase">
<!--Object/UI element that raises the event (e.g. 'Application') (pseudo-code or imaginary names are ok!) <input type="text"><br>-->
<!-- Commenting out the name to keep it simple, the event name will indicate!-->
Name of event  (e.g. 'Application Start', 'Click on button X of screen Y') <input type="text"><br>
<div id="divforconditiondetectionfn" style="display:block !important; background:#eeeeee;">
<b>Use Case condition</b><br>
<script>
	$(function()
	{
		appendVisibleElementClone("divforconditiondetectionfn", "newfndetails");
		var idofclonedele = replacements["fnreturntype"];
		//console.log("idofclonedele="+idofclonedele);
		var fnReturnTypeTextbox = $("#"+idofclonedele)[0];
		fnReturnTypeTextbox.value = "boolean (will return 'true' or 'false')";
		fnReturnTypeTextbox.readOnly = true;
		fnReturnTypeTextbox.style.backgroundColor = "#eeeeee";
	});
</script>
</div>
<div id="divforexecutionfn" style="display:block !important; background:#ddddee;">
<b>Use case action</b><br>
<script>
$(function(){appendVisibleElementClone("divforexecutionfn","newfndetails")})
</script>
</div>
</div>

</div><!-- divfortaskthatdoesnotspecifycreationofafunction -->


<div id="summAndDesc" class="classForDivForOptionForReqOrUseCase">
	Summary<button 
	onclick="copyFromTaskSummary($('#subtasksummary')[0]);"
	>Paste parent task's summary as starting point</button><br> 
	<input id="subtasksummary" type="text" size="120"><br>
	<br>
	Description<button 
	onclick="copyFromTaskDesc($('#subtaskdesc')[0]);"
	>Paste parent task's description as starting point</button><br> 
	<textarea id="subtaskdesc" rows="5" cols="120"></textarea><br>	
Note: This child task's summary and description must be enough to clearly and completely describe the task.<br> 
There should be no need to refer to the parent task's details, sibling task's details, or any other task or diagram.<br>
Unwanted details that should be part of the other child task, must not be present in the summary and description of this child task.<br>
</div><!-- end summAndDesc -->


<div id="returnconstantornewfn"> 
Does the value to be returned just need to be a constant? <select 
id="optiontoreturnconstantorcallfn" onchange="showDivForCurrentlySelectedOption(this,'classForDivForReturnConstantOrNewFn')">
<option >&nbsp;</option>
<option value="divToReturnConst">Yes</option>
<option value="divToReturnValueOfAFncall">No</option>
</select><br><br>

<div id="divToReturnConst" class="classForDivForReturnConstantOrNewFn">
<script>$(function(){appendVisibleElementClone("divToReturnConst", "returnConstant")})</script>
</div>

<div id="divToReturnValueOfAFncall" class="classForDivForReturnConstantOrNewFn" style="background:#9999ff">
<script>$(function(){appendVisibleElementClone("divToReturnValueOfAFncall", "newfndetails")})</script>
</div>

</div><!-- end of div returnconstantornewfn -->



<div id="newfndetails"> 
Describe the function (sequence of steps) to be called:<br>
Name <input type=text size="30"><br> 
Type of Data Returned (String, Number, Map of keys and values etc.) <input type=text size="30" id="fnreturntype"> <!--Description <input type=text size="90">--> <br> 
<!--File Name  </pre><input type=text size="30"><pre> --->
<!-- Let us have user defined functions as parameterless otherwise difficult to maintain binary work breakdown!
Parameter 1 <input type=text size="30"> Type <input type=text size="30"> Description <input type=text size="60"> <br> 
Parameter 2 <input type=text size="30"> Type <input type=text size="30"> Description <input type=text size="60"> <br> 
Parameter 3 <input type=text size="30"> Type <input type=text size="30"> Description <input type=text size="60"> <br>-->
<br> 
Description  <br>
<textarea rows="5" cols="120"></textarea><br>
<br>
Note the following:<br>
1. The function description must be enough to clearly and completely describe the task, without needing to refer to any other task or diagram.<br>
2. You do not have to write code inside the description of the above function. Just clearly describe what the function does.<br> 
The function will be broken into 2 parts by a crowd member as a part of another task. You will only need to review the break-down.<br>
3. The SPOCs will decide whether you have described a new, existing or ready-made function. They will decide the actual line of code.<br><br>
</div>


<div id="returnConstant" style="background:#dddddd">
Enter value of the constant <input><br>
Enter the reason for choosing this constant, any other possible values it might change to etc.<br>
<textarea id="subtaskdesc" rows="5" cols="120"></textarea><br>
</div>

<!-- TESTING: This comment should not show up in the text to paste as a comment into the issue tracking system -->
</div><!-- contentToPasteAsIssueTrackerComment -->
<br>
<button id="btnToshowNextSteps" style="display:none;" 
onclick="showNextSteps();">Next...</button>
<div id="divForNextSteps" style="display:none">
<br>
<b id="nextStepsCaption">Next steps</b><br><br> 

1. Mail the text in the textarea below to the task creator for review.<br> 
If you have edited the input fields after clicking the 'Next'button, ensure that you click the 'Next' button again:<br>
<textarea id="textForIssueTrackerComment" rows="10" cols="120" style="background:#eeffee;"></textarea><br><br>
<pre>
2. Once it is reviewed and agreed on:
	a) Paste the reviewed text as a comment into the corresponding issue in the issue trackng system.
	b) If applicable, inform the code reuse SPOC identified for this project, to review and integrate the pseudo-code that you created for this task.
	c) Create new tasks in the issue tracking system based on the sub-requirements or new functions that were identified during the breakdown of this task.

3. Once other members of the crowd start work on further breaking down these new tasks, you must act as the reviewer for these 2 breakdowns.

You can now proceed to break down other tasks assigned to you. Make sure to reserve enough time for review and rework.

</pre><b style="color:red;">Important</b><pre> 
In case of closed-source development projects: 
Do not reveal the details of any task assigned to you or created by you to anyone, except of course to:
- the reviewer (in case you are assigned to break down the task) 
- the reviewee (in case you are the reviewer)
Violation of the above will lead to financial loss for yourself, the other crowd members, your customer and organization and may be a punishable legal offence.
In case of any mistakes, you have to correct the summary and description of the tasks you created, and get it re-reviewed by your reviewer.

</pre>
</div>
</body>
</html>